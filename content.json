{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://www.furadwho.top","root":"/"},"pages":[{"title":"关于小站","date":"2021-10-23T12:05:24.563Z","updated":"2021-10-23T12:05:24.563Z","comments":false,"path":"about/index.html","permalink":"http://www.furadwho.top/about/index.html","excerpt":"","text":"关于这个小站这世上每个人的说话方式都如此拐弯抹角、闪烁其词，如此不负责任、如此微妙复杂。他们总是徒劳无功地严加防范，无时无刻不费尽心机，这让我困惑不解，最终只得随波逐流，用搞笑的办法蒙混过关，抑或默默颔首，任凭对方行事，即采取败北者的消极态度 —– 引言 本人男，已有二十余岁了，有时候回想一下似乎也咩有在这个世界上留下什么痕迹。空留一人，肚子里的各种传奇经历也只有在烂醉之后会一一道出罢了（有机会可以一起喝酒）。这个人记性不好，很多事情动不动就忘记了一干二净，技术水平也就那么回事儿，搞过不少的东西，说精通也不精通，只能说“爱好广泛”。 之前也想着开一个网站来记录，但是由于严重的拖延症导致一直在搁置着，磨磨蹭蹭，艹。 网站的主要内容就是一些儿生活琐事，电影书籍感想，技术类文档等等，现在还没有想到有什么的其他的用途，对了，交友应该也算是一个。 大概就是这样了…"},{"title":"分类","date":"2021-10-20T14:28:03.702Z","updated":"2021-10-20T14:28:03.702Z","comments":false,"path":"categories/index.html","permalink":"http://www.furadwho.top/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-10-20T14:28:03.702Z","updated":"2021-10-20T14:28:03.702Z","comments":false,"path":"books/index.html","permalink":"http://www.furadwho.top/books/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-10-23T11:24:28.543Z","updated":"2021-10-23T11:24:28.543Z","comments":false,"path":"/404.html","permalink":"http://www.furadwho.top/404.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-10-20T14:28:03.703Z","updated":"2021-10-20T14:28:03.703Z","comments":false,"path":"repository/index.html","permalink":"http://www.furadwho.top/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-10-20T14:28:03.704Z","updated":"2021-10-20T14:28:03.704Z","comments":false,"path":"tags/index.html","permalink":"http://www.furadwho.top/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-10-23T14:00:48.363Z","updated":"2021-10-23T14:00:48.363Z","comments":true,"path":"links/index.html","permalink":"http://www.furadwho.top/links/index.html","excerpt":"","text":""}],"posts":[{"title":"昨夜酒多春睡重，莫惊他。","slug":"昨夜酒多春睡重，莫惊他。","date":"2022-03-08T14:49:09.000Z","updated":"2022-03-08T15:06:21.023Z","comments":true,"path":"2022/03/08/昨夜酒多春睡重，莫惊他。/","link":"","permalink":"http://www.furadwho.top/2022/03/08/%E6%98%A8%E5%A4%9C%E9%85%92%E5%A4%9A%E6%98%A5%E7%9D%A1%E9%87%8D%EF%BC%8C%E8%8E%AB%E6%83%8A%E4%BB%96%E3%80%82/","excerpt":"","text":"![](D:\\hexo\\source_posts(f\u001cYR�\u001aY%faw͑ ����`�N\u00020\\wallhaven-2kzmgy.jpg) 昨夜酒多春睡重，莫惊他。应是很久没有写自己的东西了，似乎一切好像又回到了好久之前，感觉什么都没有发生，若是不细细去想怕是忘得一干二净了。对于很多的事情都不想去谈及，这一刻不停地流逝的时代，有些过快的步伐就想让这已经发生的事情落在后面一样，就这样待着吧，也挺不错的，是吧！ 还是有些过于不会做自己了，不会去处理事情，这就像“昨夜酒多春睡重，莫惊他。”这句诗，昨夜喝了太多的酒了，不用惊醒他，但当他明日醒来，又会不会被那夜的美梦仅仅是梦罢了这一现实而伤心呢？我觉得应该会的，因为我也尝尝做这种天真的美梦，那时候从梦中醒来，真是恼火！有关于失去了一件幸事。","categories":[{"name":"阅后即焚","slug":"阅后即焚","permalink":"http://www.furadwho.top/categories/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://www.furadwho.top/tags/emo/"}]},{"title":"2021年-总结","slug":"2021年-总结","date":"2022-01-09T15:43:32.000Z","updated":"2022-01-09T15:43:32.702Z","comments":true,"path":"2022/01/09/2021年-总结/","link":"","permalink":"http://www.furadwho.top/2022/01/09/2021%E5%B9%B4-%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Go 学习（二）","slug":"Go-学习（二）","date":"2021-12-23T07:19:01.000Z","updated":"2021-12-23T07:20:55.597Z","comments":true,"path":"2021/12/23/Go-学习（二）/","link":"","permalink":"http://www.furadwho.top/2021/12/23/Go-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"Go 学习（二）","categories":[{"name":"Go","slug":"Go","permalink":"http://www.furadwho.top/categories/Go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.furadwho.top/tags/go/"}]},{"title":"Fabric 链码编写","slug":"Fabric-链码编写","date":"2021-12-20T07:00:34.000Z","updated":"2021-12-20T07:02:01.534Z","comments":true,"path":"2021/12/20/Fabric-链码编写/","link":"","permalink":"http://www.furadwho.top/2021/12/20/Fabric-%E9%93%BE%E7%A0%81%E7%BC%96%E5%86%99/","excerpt":"","text":"Fabric 链码编写1.编写链码定义项目目录结构： chaincode：编写链码逻辑文件 model：定义结构体 test：链码测试文件 main.go：主函数定义 edu 结构体，主要包含我们上链的数据结构： 12345678910111213141516171819202122232425262728293031package educationtype Education struct &#123; ObjectType string `json:&quot;docType&quot;` UserName string `json:&quot;userName&quot;` // 姓名 Sex string `json:&quot;Sex&quot;` // 性别 UserNation string `json:&quot;UserNation&quot;` // 民族 UserIdCard string `json:&quot;UserIdCard&quot;` // 身份证号 UserAddress string `json:&quot;UserAddress&quot;` // 籍贯 BirthDay string `json:&quot;BirthDay&quot;` // 出生日期 UserEnterTime string `json:&quot;UserEnterTime&quot;` // 入学日期 GraduationDate string `json:&quot;GraduationDate&quot;` // 毕（结）业日期 UserSchool string `json:&quot;UserSchool&quot;` // 学校名称 UserMajor string `json:&quot;UserMajor&quot;` // 专业 QuaType string `json:&quot;QuaType&quot;` // 学历类别 Length string `json:&quot;Length&quot;` // 学制 Mode string `json:&quot;Mode&quot;` // 学习形式 Level string `json:&quot;Level&quot;` // 层次 Graduation string `json:&quot;Graduation&quot;` // 毕（结）业 CertNo string `json:&quot;CertNo&quot;` // 证书编号 Photo string `json:&quot;Photo&quot;` // 照片 Historys []HistoryItem // 当前 edu 的历史记录&#125;type HistoryItem struct &#123; TxId string Education Education&#125; eduChaincode.go 文件，主要负责链码的业务逻辑。主要声明 Init(stub shim.ChaincodeStubInterface)、Invoke(stub shim.ChaincodeStubInterface) 函数，完成对链码初始化及调用的相关实现 ： 12345678910111213141516171819202122232425262728293031323334// EducationChaincode 定义一个链码结构体type EducationChaincode struct &#123;&#125;// Init 实现 Init 方法，进行链码初始化// 链码升级的时候也要调用这个方法。当写一个用来升级已存在的链码的时候，请确保合理更改 Init 方法。当链码没有东西可以初始化，可以直接定义一个空的方法。func (e *EducationChaincode) Init(stub shim.ChaincodeStubInterface) peer.Response &#123; return shim.Success(nil)&#125;// Invoke 实现 Invoke 方法，进行链码的调用。func (e *EducationChaincode) Invoke(stub shim.ChaincodeStubInterface) peer.Response &#123; // 通过 stub 的 GetFunctionAndParameters() 方法提取本次调用的交易中所指定的参数.其中第一个 function 为交易参数中的第一个参数，params 为从第二个参数开始的所有参数。 fun, args := stub.GetFunctionAndParameters() if fun == &quot;addEdu&quot; &#123; // 添加信息 return e.addEdu(stub, args) &#125; else if fun == &quot;queryEduInfoByUserIdCard&quot; &#123; // 根据身份证号码查询详情 return e.queryEduInfoByUserIdCard(stub, args) &#125; else if fun == &quot;updateEdu&quot; &#123; // 根据证书编号更新信息 return e.updateEdu(stub, args) &#125; else if fun == &quot;delEdu&quot; &#123; // 根据证书编号删除信息 return e.delEdu(stub, args) &#125; // shim.Error() 此函数将创建并返回一个状态为 ERROR 的 Response 消息。 return shim.Error(&quot;指定的函数名称错误&quot;)&#125; 创建 eduChaincode.go 文件，该文件实现了使用链码相关的 API 对分类账本状态进行具体操作的各个函数： PutEdu：实现将指定的对象序列化后保存至分类账本中 GetEduInfo：根据指定的 Key（身份证号码）查询对应的状态，反序列后将对象返回 addEdu：接收对象并调用 PutEdu 函数实现保存状态的功能 queryEduInfoByEntityID：根据指定的身份证号码（Key）查询状态 updateEdu：实现对状态进行编辑功能 delEdu：从分类账本中删除状态PutEdu 函数 ： 保存用户数据 12345678910111213141516171819// PutEdu 保存数据func PutEdu(stub shim.ChaincodeStubInterface, edu education.Education) ([]byte, bool) &#123; edu.ObjectType = DOC_TYPE // json 进行 edu 结构体编码成 json 字符串 marshal, err := json.Marshal(edu) if err != nil &#123; return nil, false &#125; // stub 的 PutState() 函数将尝试在账本中添加或更新一堆键值。key 为 UserIdCard，value 为 edu // (实际上，这些值是发起了相应的交易，一直得等到区块链网络中，到最后的 peer 节点验证确认之后，才会写入账本。但是一般情况下，正常操作可以认为这一步会成功) err = stub.PutState(edu.UserIdCard, marshal) if err != nil &#123; return nil, false &#125; return marshal, true&#125; GetEduInfo 读取数据 12345678910111213141516171819202122232425 // GetEduInfo 读取数据func GetEduInfo(stub shim.ChaincodeStubInterface, UserIdCard string) (education.Education, bool) &#123; // 声明一个 edu 结构体变量 var edu education.Education // stub 的 GetState() 函数将根据 key 获取数据。 b, err := stub.GetState(UserIdCard) if err != nil &#123; return edu, false &#125; // 判断是否获取到了数据 if b == nil &#123; return edu, false &#125; // json 进行 []byte 解码成 edu 结构体 err = json.Unmarshal(b, &amp;edu) if err != nil &#123; return edu, false &#125; return edu, true&#125; addEdu 添加信息 12345678910111213141516171819202122232425262728293031323334353637// 添加信息func (e *EducationChaincode) addEdu(stub shim.ChaincodeStubInterface, args []string) peer.Response &#123; // 判断参数是否符合条件 if len(args) != 2 &#123; return shim.Error(&quot;input parameter error!&quot;) &#125; // 声明一个 edu 结构体变量 var edu education.Education // 将参数解码成结构体 err := json.Unmarshal([]byte(args[0]), &amp;edu) if err != nil &#123; return shim.Error(&quot;unmarshal has error!&quot;) &#125; // 调用 GetEduInfo() 方法 判断用户信息是否存在。 _, exist := GetEduInfo(stub, edu.UserIdCard) if exist &#123; return shim.Error(&quot;entity has exist!&quot;) &#125; // 保存用户信息 _, saveFlag := PutEdu(stub, edu) if !saveFlag &#123; return shim.Error(&quot;save edu has error!&quot;) &#125; // 设定当这个交易在 Committer 处被认证通过， 写入到区块时发送的事件(event) err = stub.SetEvent(args[1], []byte&#123;&#125;) if err != nil &#123; return shim.Error(err.Error()) &#125; return shim.Success([]byte(&quot;save edu success!&quot;))&#125; queryEduInfoByUserIdCard 根据身份证号码查询详情（溯源） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 根据身份证号码查询详情（溯源）// args: UserIdCardfunc (e *EducationChaincode) queryEduInfoByUserIdCard(stub shim.ChaincodeStubInterface, args []string) peer.Response &#123; // 判断参数是否符合条件 if len(args) != 1 &#123; return shim.Error(&quot;给定的参数个数不符合要求&quot;) &#125; // 根据身份证号码查询 edu 状态 b, err := stub.GetState(args[0]) if err != nil &#123; return shim.Error(&quot;根据身份证号码查询信息失败&quot;) &#125; if b == nil &#123; return shim.Error(&quot;根据身份证号码没有查询到相关的信息&quot;) &#125; // 对查询到的状态进行反序列化 var edu education.Education err = json.Unmarshal(b, &amp;edu) if err != nil &#123; return shim.Error(&quot;反序列化 edu 信息失败&quot;) &#125; // 获取历史变更数据 iterator, err := stub.GetHistoryForKey(edu.UserIdCard) if err != nil &#123; return shim.Error(&quot;根据指定的身份证号码查询对应的历史变更数据失败&quot;) &#125; defer iterator.Close() // 迭代处理 var historys []education.HistoryItem var hisEdu education.Education // 遍历历史记录 for iterator.HasNext() &#123; hisData, err := iterator.Next() if err != nil &#123; return shim.Error(&quot;获取 edu 的历史变更数据失败&quot;) &#125; var historyItem education.HistoryItem historyItem.TxId = hisData.TxId // 对查询到的历史记录进行反序列化 err = json.Unmarshal(hisData.Value, &amp;hisEdu) if err != nil &#123; return shim.Error(&quot;反序列化 edu 信息失败&quot;) &#125; if hisData.Value == nil &#123; var empty education.Education historyItem.Education = empty &#125; else &#123; historyItem.Education = hisEdu &#125; // 保存历史记录 historys = append(historys, historyItem) &#125; edu.Historys = historys // 返回 result, err := json.Marshal(edu) if err != nil &#123; return shim.Error(&quot;序列化 edu 信息时发生错误&quot;) &#125; return shim.Success(result)&#125; updateEdu 根据身份证号更新信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 根据身份证号更新信息// args: educationObjectfunc (e *EducationChaincode) updateEdu(stub shim.ChaincodeStubInterface, args []string) peer.Response &#123; if len(args) != 2 &#123; return shim.Error(&quot;给定的参数个数不符合要求&quot;) &#125; var info education.Education err := json.Unmarshal([]byte(args[0]), &amp;info) if err != nil &#123; return shim.Error(&quot;反序列化 edu 信息失败&quot;) &#125; // 根据身份证号码查询信息 result, bl := GetEduInfo(stub, info.UserIdCard) if !bl &#123; return shim.Error(&quot;根据身份证号码查询信息时发生错误&quot;) &#125; // 根据新的数据把旧数据进行覆盖 result.UserEnterTime = info.UserEnterTime result.GraduationDate = info.GraduationDate result.UserSchool = info.UserSchool result.UserMajor = info.UserMajor result.QuaType = info.QuaType result.Length = info.Length result.Mode = info.Mode result.Level = info.Level result.Graduation = info.Graduation result.CertNo = info.CertNo // 保存当前新数据 _, bl = PutEdu(stub, result) if !bl &#123; return shim.Error(&quot;保存信息信息时发生错误&quot;) &#125; err = stub.SetEvent(args[1], []byte&#123;&#125;) if err != nil &#123; return shim.Error(err.Error()) &#125; return shim.Success([]byte(&quot;信息更新成功&quot;))&#125; delEdu 根据身份证号删除信息（暂不对外提供） 123456789101112131415161718192021222324252627// 根据身份证号删除信息（暂不对外提供）// args: UserIdCardfunc (e *EducationChaincode) delEdu(stub shim.ChaincodeStubInterface, args []string) peer.Response &#123; if len(args) != 2 &#123; return shim.Error(&quot;给定的参数个数不符合要求&quot;) &#125; /*var edu Education result, bl := GetEduInfo(stub, info.UserIdCard) err := json.Unmarshal(result, &amp;edu) if err != nil &#123; return shim.Error(&quot;反序列化信息时发生错误&quot;) &#125;*/ // 此方法将从账本中删去相应的记录，但是不要忘了这是在区块链里，该方法将会产生相应的交易，之后将写入区块链。 err := stub.DelState(args[0]) if err != nil &#123; return shim.Error(&quot;删除信息时发生错误&quot;) &#125; err = stub.SetEvent(args[1], []byte&#123;&#125;) if err != nil &#123; return shim.Error(err.Error()) &#125; return shim.Success([]byte(&quot;信息删除成功&quot;))&#125; 2.链码 APIshim.ChaincodeStubInterface 提供了一系列 API，可以分为四类： 账本状态交互 API、交易信息相关 API、参数读取 API、其他 API。 账本状态交互 APIfabric 记录的数据，我们称之为状态(state),这些以键值对(key-value)的形式存储。而账本状态交互 API 可以对账本状态进行操作，相应的，方法会更新交易提案的读写集。 API 方法格式 说明 GetState GetState(key string) ([]byte, error) 负责查询账本，返回指定键对应的值 PutState PutState(key string, value []byte) error 尝试在账本中添加或更新一对键值。 这一对键值会被添 加到写集合中，等待 Committer 进一步的验证，验证通 过后会真正写入到账本 GetStateByRange GetStateByRange(startKey, endKey string) (StateQuerylteratorlnterface,error) 查询指定范围内的键值，startKey、endKey 分别 指定起始(包括)和终止(不包括)，当为空时默认是最大范围 。 返回结果是一个迭代器 StateQuerylteratorlnterface 结构， 可以按照字典序迭代每个键值对, 最后需调用 Close()方 法关闭 GetStateByPartialCompositeKey GetStateByPartialCompositeKey (objectType string, keys []string) (StateQuerylteratorlnterface, error) 根据局部的复合键(前缀)返回所有匹配的键值。 返回结 果也是一个迭代器 StateQuerylteratorlnterface 结构，可以按照字典序迭代每个键值对，最后需调用 C lose()方法关闭 GetHistoryForKey GetHistoryForKey(key string) (History Querylteratorlnterface, error) 返回某个键的所有历史值 。 需要在节点配置中打开历史数据库特性 (Iedger.history.enableHistoryDatabase= true) GetQueryResult GetQueryResult(query string) (State Querylteratorlnterface, error) 对(支持富查询功能的)状态数据库进行富查询( rich query)。 返回结果为迭代器结构 StateQueryIteratorInterface。 注意该方法不会被 Committer 重新执行进行验证，因此， 不应该用于更新账本状态的交易中 。 目前仅有 CouchDB 类型的状态数据库支持富查询 交易信息相关 API此类 API 可以获取到与交易自身相关的数据。用户对链码的调用会产生一系列的交易提案，这些 API 支持查询当前交易提案的一些属性。 API 方法格式 说明 GetTxID GetTxID() string 该方法返回交易提案中指定的交易 ID。一般情况下， 交易 ID 是在客户端生成提案时候产生的数字摘要，由 Nonce 随机串和签名者身份信息，一起进行 SHA256 哈希运行生成 GetTxTimestamp GetTxTimestamp() (*timestamp. Timestamp, error) 返回交易被创建时的客户端打上的时间戳 。 这个时间戳 是 直接从交易 ChannelHeader 中提取的，所以在所有背书节点 (endorsers)处看到的值都相同 GetBinding GetBinding() ([]byte，eπor) 返回交易的 binding 信息。注意:交易的 binding 信息是将交易提案的 nonse、Creator、epoch 等信息组合起来，再进行晗希得到的数字摘要 GetSignecjProposal GetSignedProposal()(*pb.SignedProposal, eηor) 返回该 stub 的 SignedProposal 结构，包括了跟交易提案相 关的所有数据 GetCreator GetCreator() ([]byte, eπor) 返回该交易的提交者的身份信息，从 signedProposal 中的 SignatureHeader.Creator 提取 GetTransient GetTransient()(map[string][]byte, error) 返回交易中带有的 一 些临时信息，从 ChaincodeProposalPayload.transient 域提取，可以存放一 些应用相关的保密信息，这些信息不会被写到账本中 参数读取 API调用链码事支持传入若干参数，参数可通过 API 读取。 API 方法格式 说明 GetArgs GetArgs() [][]byte 提取调用链码时交易 Proposal 中指定的参数，以字节串 (ByteArray)数组形式返回。 可以在 Init 或 Invoke 方法中使用。 这些参数从 ChaincodeSpec 结构中的 Input 域直接提取 GetArgsSlice GetArgsSlice() ([]byte, error) 提取调用链码时交易 Proposal 中指定的参数，以字节串形式返回 GetFunctionAndParameters GetFunctionAndParameters()(string, []string) 这是链码开发者和用户约定俗成的习惯，即在 Init/Invoke 方法中编写实现若干子函数，用户调用时以第一个参数作为函数名 ， 链码中的代码根据函数名称可以仅执行对应的分支处理逻辑 GetStringArgs GetStringArgs() []string 提取调用链码时交易 Proposal 中指定的参数，以 字 符串 (String) 数组形式返回 其他 API上面是常用的 API，同时还有一些辅助 API API 方法格式 说明 CreateCompositeKey CreateCompositeKey(objectType string, attributes []string) (string, error) 给定一组属性( attributes)，该 API 将这些属性组合起来构造返回一个复合键 。 返回的复合键可以被 PutState 等方法使用 。objectType 和 attributes 只允许合法的 utf8 字符串，并且不能包含 U+OOOO 和 U+10FFFF SplitCompositeKey SplitCompositeKey(compositeKey string) (string, []string, error) 该方法与 CreateCompositeKey 方法相对，给定一个复合键，将其拆分为构造复合键时所用的属性 InvokeChaincode InvokeChaincode(chaincodeName string, args [][]byte, channel string) pb.Response 调用另一个链码中的 Invoke 方法，如果被调用链码在同一个通道内，则添加其读写集合信息到调用交易; 否则执行调用但不影响读写集合信息 。 如果 channel 为空 ，则默认为当前通道。 目前仅限于读操作，同时不会生成新的交易 SetEvent SetEvent(name string, payload []byte) error 设定当这个交易在 Committer 处被认证通过， 写入到 区块时发送的事件( event)","categories":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://www.furadwho.top/categories/Hyperledger-Fabric/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://www.furadwho.top/tags/Fabric/"}]},{"title":"阅后即焚（七）","slug":"阅后即焚（七）","date":"2021-12-12T13:53:00.000Z","updated":"2021-12-12T12:51:10.981Z","comments":true,"path":"2021/12/12/阅后即焚（七）/","link":"","permalink":"http://www.furadwho.top/2021/12/12/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A%EF%BC%88%E4%B8%83%EF%BC%89/","excerpt":"","text":"阅后即焚（七） ​ 这篇文章我想了好久，一直没有动笔，总是有这样的感觉，脑子里有了好多的想法但是都迟迟不知道怎么去写和表达自己的想法。 ​ 我在想几件事情，包括小赵看到这样的文章会有什么样的感觉？好像只要不是“这个男的脑子有病吧！天天这么多b事。”就还好吧。这样的时候还是蛮奇怪的，自己去幻想一些别人对自己的感受，而没有直接去询问。还是挺离谱的。 ​ 最近没有怎么去和小赵联系，分享自己的一些事情。主要的原因还是由于快考试了，虽然应该一直陪着小赵会蛮好的，可还是稍微保持一些距离，毕竟学习还是一件需要些安静平和的时刻。不知道小赵会不会了解和理解我这样的想法，不理解就不理解吧。这样的我，确实 就是这样的我。小赵好好考试学习，才是这段时期最为关键的事情。 ​ 这篇文章是 11 月 11 日建立的，今天是 12 月 12 日开始写的，这个月发生什么事情。减少了联系，工作又变成了线下，每天都是一些乱七八糟的事情。前段时间，在朋友圈和他们一样发了一个匿名的提问箱，去询问大家关于自己的一些问题。（希望小赵可以看见，最好还可以发一个问题，哈哈哈） ​ 里面有一个问题是“真心喜欢过几个人？”。看到这个问题，迟疑了一段时间，我到底真心喜欢过几个人。“过去一个，现在一个” ，现在这一个真的算是我喜欢的人嘛。开始对于我和小赵这段自己的感情去反思了一下，有些怀疑到底喜欢不喜欢，或者说是怎么才叫做‘真心喜欢’ ​ 我不知道，也有些累了，总是去提问自己，一直没有答复。 ​ 有时候，我还真的挺想去问问小赵，你觉得我到底怎么样，那种真心的回答，你可以不可以主动的联系我，和我分享分享你的生活。我说不出口…","categories":[{"name":"阅后即焚","slug":"阅后即焚","permalink":"http://www.furadwho.top/categories/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://www.furadwho.top/tags/emo/"}]},{"title":"闲谈","slug":"闲谈","date":"2021-12-12T11:55:36.000Z","updated":"2021-12-12T12:08:43.374Z","comments":true,"path":"2021/12/12/闲谈/","link":"","permalink":"http://www.furadwho.top/2021/12/12/%E9%97%B2%E8%B0%88/","excerpt":"","text":"","categories":[{"name":"闲谈","slug":"闲谈","permalink":"http://www.furadwho.top/categories/%E9%97%B2%E8%B0%88/"}],"tags":[{"name":"say","slug":"say","permalink":"http://www.furadwho.top/tags/say/"}]},{"title":"Go net/http 解析","slug":"Go-net-http-解析","date":"2021-12-09T06:54:36.000Z","updated":"2021-12-09T06:58:49.509Z","comments":true,"path":"2021/12/09/Go-net-http-解析/","link":"","permalink":"http://www.furadwho.top/2021/12/09/Go-net-http-%E8%A7%A3%E6%9E%90/","excerpt":"","text":"","categories":[{"name":"Go","slug":"Go","permalink":"http://www.furadwho.top/categories/Go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.furadwho.top/tags/go/"}]},{"title":"Go json 解析","slug":"Go-json-解析","date":"2021-12-08T06:31:12.000Z","updated":"2021-12-23T07:21:12.273Z","comments":true,"path":"2021/12/08/Go-json-解析/","link":"","permalink":"http://www.furadwho.top/2021/12/08/Go-json-%E8%A7%A3%E6%9E%90/","excerpt":"","text":"","categories":[{"name":"Go","slug":"Go","permalink":"http://www.furadwho.top/categories/Go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.furadwho.top/tags/go/"}]},{"title":"Hyperledger Fabric 学习","slug":"Hyperledger-Fabric-学习","date":"2021-12-01T08:00:17.000Z","updated":"2021-12-01T08:21:00.745Z","comments":true,"path":"2021/12/01/Hyperledger-Fabric-学习/","link":"","permalink":"http://www.furadwho.top/2021/12/01/Hyperledger-Fabric-%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://www.furadwho.top/categories/Hyperledger-Fabric/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://www.furadwho.top/tags/Fabric/"}]},{"title":"学了一个月，什么是Hyperledger Fabric","slug":"学了一个月，什么是Hyperledger-Fabric","date":"2021-11-30T07:06:01.000Z","updated":"2021-11-30T07:45:32.583Z","comments":true,"path":"2021/11/30/学了一个月，什么是Hyperledger-Fabric/","link":"","permalink":"http://www.furadwho.top/2021/11/30/%E5%AD%A6%E4%BA%86%E4%B8%80%E4%B8%AA%E6%9C%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AFHyperledger-Fabric/","excerpt":"","text":"","categories":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://www.furadwho.top/categories/Hyperledger-Fabric/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://www.furadwho.top/tags/Fabric/"}]},{"title":"Go 学习（一）","slug":"Go-学习（一）","date":"2021-11-23T00:30:02.000Z","updated":"2021-12-22T09:56:50.690Z","comments":true,"path":"2021/11/23/Go-学习（一）/","link":"","permalink":"http://www.furadwho.top/2021/11/23/Go-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"Go 学习（一）基础1 基础部分Go语言基本结构及说明 12345678910package mainimport ( &quot;fmt&quot; &quot;runtime&quot;)func main() &#123; fmt.Println(&quot;hello world&quot;) // 查看版本 fmt.Println(runtime.Version())&#125; func main()是程序入口。所有Go函数以关键字func开头，每一个可执行程序都必须包含main()函数，通常是程序启动后第一个执行的函数，如果有init()函数则会先执行init()函数。 除此之外，还有以下几点值得注意。 （1）只有package名称为main的包可以包含main()函数。 （2）一个可执行程序有且仅有一个main包。 （3）通过import关键字来导入其他非main包。 （4）可以通过import关键字单个导入，也可以同时导入多个。 2 基本语法2.1 变量变量的本质是计算机分配的一小块内存，专门用于存放指定数据，在程序运行过程中该数值可以发生改变；变量的存储往往具有瞬时性，或者说是临时存储，当程序运行结束，存放该数据的内存就会释放，该变量就会随着内存的释放而消失。就像日常生活中存放水的水杯，当水杯损坏的时候，装在里面的水也会流失掉。 变量又分为局部变量和全局变量。 局部变量，是定义在大括号（{}）内部的变量，大括号的内部也是局部变量的作用域。 全局变量，是定义在函数和大括号（{}）外部的变量。 Go 语言的变量名由字母、数字、下画线组成，首个字符不能为数字；Go 语法规定，定义的局部变量若没有被调用会发生编译错误。 变量声明 未初始化变量的默认值有如下特点： 整型和浮点型变量默认值：0。 字符串默认值为空字符串。 布尔型默认值为false。 函数、指针变量、切片默认值为nil。 初始化变量的标准格式如下： 123var a int = 199 //初始化变量的标准格式var b = 100 //初始化变量的编译器自动推断类型格式c := 123 //初始化变量的简短声明格式 使用 := 赋值操作符可以高效地创建一个新的变量，称为初始化声明。声明语句省略了 var 关键字，变量类型将由编译器自动推断。这是声明变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。该变量名必须是没有定义过的变量，若定义过，将发生编译错误。 1234567package mainfunc main()&#123; // 这样写是错误的 var a = 123 a := 222&#125;./variable.go:7:4: no new variables on left side of := 多个短变量声明和赋值中，至少有一个新声明的变量出现在左侧，那么即便其他变量名可能是重复声明的，编译器也不会报错。情况如下所示： 123456789package mainimport &quot;fmt&quot;func main()&#123; // 这种情况不会报错 var a = 666 a, b := 1,2 fmt.Println(&quot;a&gt;&gt;&gt;&quot;,a) // 1 fmt.Println(&quot;n&gt;&gt;&gt;&quot;,b) // 2&#125; 虽然这种方法不会报错，但是在使用过程中应尽量避免。 变量多重赋值 变量多重赋值是指多个变量同时赋值。 Go语法中，变量初始化和变量赋值是两个不同的概念。Go语言的变量赋值与其他语言一样，但是Go提供了其他程序员期待已久的多重赋值功能，可以实现变量交换。多重赋值让Go语言比其他语言减少了代码量。 go语言中使用多重赋值进行变量交换的例子： 12345678910package mainimport &quot;fmt&quot;func main()&#123; var a = 666 a, b := 111,222 // 变量交换 b, a = a, b fmt.Println(&quot;a&gt;&gt;&gt;&quot;,a) // 222 fmt.Println(&quot;n&gt;&gt;&gt;&quot;,b) // 111&#125; 需要注意的是，多重赋值时，左值和右值按照从左到右的顺序赋值。这种方法在错误处理和函数当中会大量使用。 匿名变量 Go语言的函数可以返回多个值，而事实上并不是所有的返回值都用得上。那么就可以使用匿名变量，用下画线“_”替换即可。 例如，定义一个函数，功能为返回两个int型变量，第一个返回10，第二个返回20，第一次调用舍弃第二个返回值，第二次调用舍弃第一个返回值，具体语法格式如下所示。 12345678910111213package mainimport &quot;fmt&quot;func getData()(int, string, bool)&#123; return 666,&quot;whw&quot;,false&#125;func main()&#123; var a = 666 a, b, _ := getData() fmt.Println(&quot;a&gt;&gt;&gt;&quot;,a) // 666 fmt.Println(&quot;n&gt;&gt;&gt;&quot;,b) // whw&#125; 匿名变量既不占用命名空间，也不会分配内存。 2.2 数据类型在Go语言中，有以下几种数据类型： 基本数据类型（原生数据类型）：整型、浮点型、复数型、布尔型、字符串、字符（byte、rune）。 复合数据类型（派生数据类型）：数组（array）、切片（slice）、映射（map）、函数（function）、结构体（struct）、通道（channel）、接口（interface）、指针（pointer）。 整型整型分两大类。有符号整型：int8、int16、int32、int64、int。 无符号整型：uint8、uint16、uint32、uint64、uint。 其中uint8就是byte型，int16对应C语言的short型，int64对应C语言的long型。 浮点型 常量math.MaxFloat32表示float32能获取的最大值，大约是3.4×1038；常量math.SmallestNonzeroFloat32表示float32能获取的最小值，大约为1.4×10-45。 常量math.MaxFloat64表示float64能获取的最大值，大约是1.8×10308；常量math.SmallestNonzeroFloat64表示float64能获取的最小值，大约为4.9×10-324。 复数型复数型用于表示数学中的复数，如1+2j、1-2j、-1-2j等。关于复数型的说明，如表2.3所示。 布尔型布尔型用预定义标识符bool表示。在C语言中，对于布尔型的值定义，非0表示真，0表示假。而在Go语言中，布尔型的值只可以是常量true或者false。 声明方式如下所示。 1var flag bool 布尔型无法参与数值运算，也无法与其他类型进行转换。 字符串字符串在Go语言中是以基本数据类型出现的，使用字符串就像使用其他原生基本数据类型int、float32、float64、bool一样。 字符串在C++语言中，以类的方式进行封装，不属于基本数据类型。 在go中使用字符串： 1234var s1 string //定义名为s1的字符串类型变量s1 = &quot;HelloWorld&quot; //变量赋值student1 := &quot;火影whw&quot; //以自动推断方式初始化 有些字符串没有现成的文字代号，所以只能用转义字符来表示。常用的转义字符如表2.4所示： 定义多行字符串的方法如下： 双引号书写字符串被称为字符串字面量（string literal），这种字面量不能跨行。 多行字符串需要使用反引号“`”，多用于内嵌源码和内嵌数据。 在反引号中的所有代码不会被编译器识别，而只是作为字符串的一部分。 多行字符串定义方式如例2-1所示。 12345678910111213141516package mainimport &quot;fmt&quot;func getString()(string)&#123; s1 := ` x := 123 y := 666 ss := &quot;A Hero&#x27;s Country!&quot; ` return s1&#125;func main()&#123; a := getString() fmt.Println(&quot;a&gt;&gt;&gt;&quot;,a)&#125; 字符字符串中的每一个元素叫作“字符”，定义字符时使用单引号。Go语言的字符有两种，如表2.5所示。 声明示例如下（注意必须是单引号！）： 12345678910package mainimport &quot;fmt&quot;func main()&#123; // 注意必须是单引号！！！ var a byte = &#x27;s&#x27; var b rune = &#x27;王&#x27; fmt.Println(&quot;a&gt;&gt;&gt;&quot;,a) // 115 fmt.Println(&quot;b&gt;&gt;&gt;&quot;,b) // 29579&#125; 2.3 打印格式化打印格式化通常使用fmt包，通用的打印格式如表： 具体的使用方法： 123456789101112131415package mainimport &quot;fmt&quot;func main()&#123; str := &quot;wanghw&quot; fmt.Printf(&quot;%T, %v \\n&quot;,str,str) //string, wanghw var a rune = &#x27;王&#x27; fmt.Printf(&quot;%T, %v \\n&quot;,a,a) //int32, 29579 var b byte = &#x27;b&#x27; fmt.Printf(&quot;%T, %v \\n&quot;,b,b) //uint8, 98 var c int32 = 123 fmt.Printf(&quot;%T, %v \\n&quot;,c,c) //int32, 123&#125; 通过上例可以看出，使用通用的格式打印，输出的结果可能不是自己想要的，为了确保输出结果与需求一致，还需要学习具体格式的打印方式。 布尔型打印格式 123456789101112package mainimport &quot;fmt&quot;func main()&#123; var flag bool // flag默认是false fmt.Printf(&quot;%T, %t \\n&quot;,flag,flag) //bool, false flag = true fmt.Printf(&quot;%T, %t \\n&quot;,flag,flag) //bool, true&#125; 整型打印格式 1234567891011121314package mainimport &quot;fmt&quot;func main()&#123; fmt.Printf(&quot;%T, %d \\n&quot;,123, 123) //int, 123 fmt.Printf(&quot;%T, %5d \\n&quot;,123, 123) //int, 123 fmt.Printf(&quot;%T, %05d \\n&quot;,123, 123) //int, 00123 fmt.Printf(&quot;%T, %b \\n&quot;,123, 123) //int, 1111011 fmt.Printf(&quot;%T, %o \\n&quot;,123, 123) //int, 173 fmt.Printf(&quot;%T, %c \\n&quot;,98, 98) //int, b fmt.Printf(&quot;%T, %q \\n&quot;,98, 98) //int, &#x27;b&#x27; fmt.Printf(&quot;%T, %x \\n&quot;,123, 123) //int, 7b fmt.Printf(&quot;%T, %X \\n&quot;,123, 123) //int, 7B fmt.Printf(&quot;%T, %U \\n&quot;,&#x27;王&#x27;, &#x27;王&#x27;) //int32, U+738B&#125; 浮点型与复数型打印格式 12345678910111213package mainimport &quot;fmt&quot;func main()&#123; fmt.Printf(&quot;%b \\n&quot;,123.23433) //8671845041675824p-46 fmt.Printf(&quot;%f \\n&quot;,123.2) //123.200000 fmt.Printf(&quot;%.2f \\n&quot;,123.22222) //123.22 fmt.Printf(&quot;%e \\n&quot;,123.22222) //1.232222e+02 fmt.Printf(&quot;%E \\n&quot;,123.22222) //1.232222E+02 fmt.Printf(&quot;%.1e \\n&quot;,123.22222) //1.2e+02 fmt.Printf(&quot;%F \\n&quot;,123.22222) //123.222220 fmt.Printf(&quot;%g \\n&quot;,123.22222) //123.22222 fmt.Printf(&quot;%G \\n&quot;,123.22222) //123.22222 &#125; 关于复数的打印格式如下123456789package mainimport &quot;fmt&quot;func main()&#123; var value complex64 = 2.2 + 22i value2 := complex(2.2,222) fmt.Println(real(value)) //2.2 fmt.Println(imag(value)) //22 fmt.Println(value2) //(2.2+222i)&#125; 字符串打印与字节数组的打印格式 1234567891011121314package mainimport &quot;fmt&quot;func main()&#123; arr := []byte&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;&#125; fmt.Printf(&quot;%s \\n&quot;,&quot;火影whw&quot;)//火影whw fmt.Printf(&quot;%q \\n&quot;,&quot;火影whw&quot;)//&quot;火影whw&quot; fmt.Printf(&quot;%x \\n&quot;,&quot;火影whw&quot;)//e781abe5bdb1776877 fmt.Printf(&quot;%X \\n&quot;,&quot;火影whw&quot;)//E781ABE5BDB1776877 fmt.Printf(&quot;%T, %s \\n&quot;,arr, arr)//[]uint8, abcd fmt.Printf(&quot;%T, %q \\n&quot;,arr, arr)//[]uint8, &quot;abcd&quot; fmt.Printf(&quot;%T, %x \\n&quot;,arr, arr)//[]uint8, 61626364 fmt.Printf(&quot;%T, %X \\n&quot;,arr, arr)//[]uint8, 61626364 &#125; 2.4 数据类型转换Go语言采用数据类型前置加括号的方式进行类型转换，格式如：T（表达式）。T表示要转换的类型；表达式包括变量、数值、函数返回值等。 类型转换时，需要考虑两种类型之间的关系和范围，是否会发生数值截断。就像将1000毫升的水倒入容积为500毫升的瓶子里，余出来500毫升的水便会流失。值得注意的是，布尔型无法与其他类型进行转换。 123456789package mainimport &quot;fmt&quot;func main()&#123; a := 100 b1 := float64(a) b2 := string(a) fmt.Println(&quot;b1&gt;&gt;&gt;&quot;,b1) fmt.Println(&quot;b2&gt;&gt;&gt;&quot;,b2)&#125; 浮点型与整型之间转换float和int的类型精度不同，使用时需要注意float转int时精度的损失。 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; chinese := 90 english := 98.9 avg1 := (chinese + int(english)) / 2 avg2 := (float64(chinese) + english) / 2 fmt.Println(&quot;avg1&gt;&gt;&gt;&quot;,avg1) // 94 fmt.Println(&quot;avg2&gt;&gt;&gt;&quot;,avg2) // 94.45&#125; 整型转字符串类型这种类型的转换，其实相当于byte或rune转string。 int数值是ASCII码的编号或unicode字符集的编号，转成string就是根据字符集，将对应编号的字符查找出来。当该数值超出unicode编号范围，则转成的字符串显示为乱码。例如，19968转string，就是“一”。 备注： ASCII字符集中数字的十进制范围是48～57； ASCII字符集中大写字母的十进制范围是65～90； ASCII字符集中小写字母的十进制范围是97～122； unicode字符集中汉字的范围是4e00～9fa5，十进制范围是19968～40869。 详情如下： 具体的使用方法如下： 1234567891011package mainimport &quot;fmt&quot;func main() &#123; a := 97 x := 19969 ret1 := string(a) ret2 := string(x) fmt.Println(&quot;ret1&gt;&gt;&gt;&quot;,ret1) // a fmt.Println(&quot;ret2&gt;&gt;&gt;&quot;,ret2) // 丁&#125; Go语言中不允许字符串转int 12345678package mainimport &quot;fmt&quot;func main() &#123; a := &quot;丁&quot; // 不能将字符串转为int ret1 := int64(a) fmt.Println(&quot;ret1&gt;&gt;&gt;&quot;,ret1) // a&#125; 会上报下面的错误： 1cannot convert a (type string) to type int64 2.5 常量常量是一个简单值的标识符，在程序运行时，不会被修改。常量中的数据类型只可以是布尔型、数字型（整型、浮点型和复数型）和字符串。常量的定义格式如下： 12345const A string = &quot;wanghw&quot;const B = &quot;whw&quot;const C, D = &quot;www&quot;, &quot;waa&quot; 常量定义后未被使用，不会在编译时报错。 常量用于枚举Go语言现阶段没有提供枚举，可以使用常量组模拟枚举。 假设数字0、1和2分别代表未知性别、女性和男性。格式如例： 123456789101112package mainimport &quot;fmt&quot;const ( Unknown = 0 Female = 1 Male = 2)func main()&#123; fmt.Println(&quot;ret&gt;&gt;&quot;,Unknown, Female, Male) // 结果 // ret&gt;&gt; 0 1 2&#125; 常量组中如果不指定类型和初始值，则与上一行非空常量的值相同： 123456789101112package mainimport &quot;fmt&quot;const ( a = 10 b c)func main()&#123; fmt.Println(&quot;ret&gt;&gt;&quot;,a, b, c) // 结果 // ret&gt;&gt; 10 10 10&#125; iotaiota，特殊常量值，是一个系统定义的可以被编译器修改的常量值。 iota只能被用在常量的赋值中，在每一个const关键字出现时，被重置为0，然后每出现一个常量，iota所代表的数值会自动增加1。 iota可以理解成常量组中常量的计数器，不论该常量的值是什么，只要有一个常量，那么iota就加1。 123456789101112package mainimport &quot;fmt&quot;const ( a = 12 b = iota c = iota)func main()&#123; fmt.Println(&quot;ret&gt;&gt;&quot;,a, b, c) // 结果 // ret&gt;&gt; 12 1 2&#125; 常量组中如果不指定类型和初始值，则与上一行非空常量的值相同： 123456789101112package mainimport &quot;fmt&quot;const ( a = iota b c)func main()&#123; fmt.Println(&quot;ret&gt;&gt;&quot;,a, b, c) // 结果 // ret&gt;&gt; 0 1 2&#125; 2.6 类型别名与类型定义类型别名是Go1.9版本添加的新功能。说到类型别名，无非是给类型名取一个有特殊含义的外号而已，就像武侠小说中的东邪西毒。假如在教室中，有两个同学叫张三，老师为了区分他们，通常会给他们起个别名：大张三、小张三。对于编程而言，类型别名主要用于解决兼容性的问题。 该语句是将NewString定义为string类型。通过type关键字，NewString会形成一种新的类型。NewString本身依然具备string的特性。 1type StringAliaa = string 该语句是将StringAlias定义为string的一个别名。使用StringAlias与string等效。别名类型只会在代码中存在，编译完成时，不会有别名类型。 出于对程序性能的考虑，建议如下： 尽可能地使用 := 去初始化声明一个变量（在函数内部）。 尽可能地使用字符代替字符串。 2.7 Go语言运算符运算符用于在程序运行时执行数学或逻辑运算。 Go语言内置的运算符包括算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、其他运算符。 逻辑运算符 Go语言的逻辑运算符如表所示。假定A值为True，B值为False。 位运算符 位运算符对整数在内存中的二进制位进行操作。 位运算符比一般的算术运算符速度要快，而且可以实现一些算术运算符不能实现的功能。如果要开发高效率程序，位运算符是必不可少的。位运算符用来对二进制位进行操作，包括：按位与（＆）、按位或（|）、按位异或（^）、按位左移（＜＜）、按位右移（＞＞）。 Go语言支持的位运算符如表2.15所示。假定A为60，B为13： （其他略） 其他运算符 运算符优先级 当然，读者可以通过使用括号来临时提升某个表达式的整体运算优先级。 3 Go语言的流程控制3.1 流程控制概述3.2 if条件判断语句 先判断if的布尔表达式，如果为true，其后紧跟的语句块执行，如果为false，再判断else if的布尔表达式，如果为true，其后紧跟的语句块执行，如果为false，再判断下一个else if的布尔表达式，以此类推，当最后一个else if的表达式为false时，执行else语句块。 在if语句的使用过程中，应注意以下细节： 不需使用括号将条件包含起来。 大括号{}必须存在，即使只有一行语句。 左括号必须在if或else的同一行。 在if之后，条件语句之前，可以添加变量初始化语句，使用“;”进行分隔。 if的特殊写法if语句还有一个变体。它的语法如下所示。 123456789101112131415if statement; condition &#123; // 代码块&#125;package mainimport &quot;fmt&quot;func main()&#123; if num := 10; num %2 == 0&#123; fmt.Println(&quot;偶数&quot;) &#125; else&#123; fmt.Println(&quot;奇数&quot;) &#125;&#125;// 结果// 偶数 需要注意的是，num的定义在if里，那么只能够在该if…else语句块中使用，否则编译器会报错。 3.3 if嵌套语句 3.4 switch语句 switch语句执行的过程自上而下，直到找到case匹配项，匹配项中无须使用break，因为Go语言中的switch默认给每个case自带break。因此匹配成功后不会向下执行其他的 case 分支，而是跳出整个 switch。可以添加fallthrough（中文含义是：贯穿），强制执行后面的case分支。fallthrough必须放在case分支的最后一行。如果它出现在中间的某个地方，编译器就会报错。变量var1可以是任何类型，而val1和val2则可以是同类型的任意值。类型不局限于常量或整数，但必须是相同类型或最终结果为相同类型的表达式。case后的值不能重复，但可以同时测试多个符合条件的值，也就是说case后可以有多个值，这些值之间使用逗号分隔，例如：case val1, val2, val3。switch后的表达式可以省略，默认是switch true。 示例 接下来再看一个案例，判断某年某月的天数 类型转换 switch语句还可以被用于type switch（类型转换）来判断某个interface变量中实际存储的变量类型。关于interface变量的知识将在后续的章节中介绍。下面演示type switch的语法。其语法结构如下所示。 3.5 for循环语句循环语句表示当条件满足时，可以反复地执行某段代码。 for是Go语言中唯一的循环语句，Go没有while、do…while循环。 按语法结构来分，Go语言的for循环有4种形式，只有第一种使用分号。 for循环中for关键字后不能加小括号。 语法结构一123for 初始预计init; 条件表达式condition; 结束语句post &#123; // 循环体代码&#125; 先执行初始语句，对控制变量赋初始值。初始语句只执行一次。 其次根据控制变量判断条件表达式的返回值，若其值为true，满足循环条件，则执行循环体内语句，之后执行结束语句，开始下一次循环。 执行结束语句之后，将重新计算条件表达式的返回值，如果是true，循环将继续执行，否则循环终止。然后执行循环体外语句。 12345678package mainimport &quot;fmt&quot;func main()&#123; for i:=0; i&lt;10; i++&#123; fmt.Printf(&quot;%d &quot;, i) &#125;&#125;//0 1 2 3 4 5 6 7 8 9 初始语句、条件表达式和结束语句3种组成部分都是可选的。因此这种基本的for循环语法结构又能演化出4种略有不同的写法。 初始语句是在第一次循环前执行的语句，一般为赋值表达式，给控制变量赋初始值。如果控制变量在此处被声明，其作用域将被局限在这个for的范围内——在for循环中声明的变量仅在循环范围内可用。初始语句可以省略不写，但是初始语句之后的分号必须要写。 省略初始语句的写法： 123456789package mainimport &quot;fmt&quot;func main()&#123; a := 3 for ; a&lt;5; a++&#123; fmt.Printf(&quot;%d &quot;, a) &#125;&#125;//3 4 条件表达式（condition）是控制循环与否的开关：如果表达式为true，则循环继续；否则结束循环。条件表达式可以省略不写，之后的分号必须要写。省略条件表达式默认形成无限循环。 省略条件表达式的写法： 123456789101112package mainimport &quot;fmt&quot;func main()&#123; a := 3 for ; ; a++ &#123; if a &gt; 5 &#123; fmt.Printf(&quot;%d &quot;, a) break &#125; &#125;&#125;//6 结束语句（post），一般为赋值表达式，使控制变量递增或者递减。post语句将在循环的每次成功迭代之后执行。 语法结构二for关键字后只有1个条件表达式，效果类似其他编程语言中的while循环。其语法结构如下所示。 12345678910111213for 循环条件condition&#123; // 循环体代码&#125;package mainimport &quot;fmt&quot;func main()&#123; var a int for a&lt;10&#123; fmt.Print(a) a ++ &#125;&#125;//0123456789 语法结构三for关键字后无表达式，效果与其他编程语言的for(;;) {}一致，此时for执行无限循环。其语法结构如下所示。 1234567891011121314151617for &#123; // 循环体代码&#125;package mainimport &quot;fmt&quot;func main() &#123; var a int for &#123; if a &gt; 5 &#123; break &#125; fmt.Print(a) a++ &#125;&#125;//012345 语法形式四（for … range）for循环的range格式对string、slice、array、map、channel等进行迭代循环。 array、slice、string返回索引和值；map返回键和值；channel只返回通道内的值。 其语法结构如下所示: 12345678910111213141516171819202122for key, value := range oldMap&#123; newMap[key] = value&#125;package mainimport &quot;fmt&quot;func main() &#123; str := &quot;123abC火影王&quot; for i, value := range str&#123; fmt.Printf(&quot;第 %d 位的ASCII值=%d，字符是%c \\n&quot;,i, value, value) &#125;&#125;/*第 0 位的ASCII值=49，字符是1第 1 位的ASCII值=50，字符是2第 2 位的ASCII值=51，字符是3第 3 位的ASCII值=97，字符是a第 4 位的ASCII值=98，字符是b第 5 位的ASCII值=67，字符是C第 6 位的ASCII值=28779，字符是火第 9 位的ASCII值=24433，字符是影第 12 位的ASCII值=29579，字符是王*/ for循环使用案例求1～100的和12345678910package mainimport &quot;fmt&quot;func main() &#123; sum := 0 for i:=1; i&lt;=100; i++&#123; sum += i &#125; fmt.Print(&quot;sum&gt;&gt;&gt;&quot;,sum)&#125;//5050 求1～30所有3的倍数的数字的和12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;func main() &#123; i := 1 sum := 0 //死循环 for &#123; if i&gt;30&#123; break &#125; if i%3 == 0&#123; sum += i fmt.Printf(&quot;%d&quot;,i) if i&lt;30&#123; fmt.Print(&quot;+&quot;) &#125;else&#123; fmt.Printf(&quot; = %d \\n&quot;,sum) &#125; &#125; i++ &#125;&#125;//3+6+9+12+15+18+21+24+27+30 = 165 截竹竿问题截竹竿。32米竹竿，每次截1.5米，至少截几次之后剩余竹竿不足4米？ 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; var length float32 length = 32 i := 0 for length &gt; 4 &#123; length -= 1.5 i += 1 &#125; fmt.Printf(&quot;一共截了 %d 次&quot;, i)&#125;//一共截了 19 次 3.6 for循环嵌套语法结构Go语言允许在循环体内使用循环。其语法结构如下所示： 12345678for [condition | (init;condition;increment) | Range] &#123; for [condition | (init;condition;increment) | Range] &#123; statement(s); &#125; statement(s);&#125; 使用案例打印直角三角形 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func main() &#123; // 定义行数 lines := 5 for i:=0;i&lt;lines;i++&#123; for n:=0;n&lt;2*i+1;n++&#123; fmt.Print(&quot;# &quot;) &#125; fmt.Print(&quot;\\n&quot;) &#125;&#125;/*## # ## # # # ## # # # # # ## # # # # # # # #*/ 打印99乘法表 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &#123; for i:=1;i&lt;=9;i++&#123; // i控制行数，是乘法表中的第二个数 for j:=1;j&lt;=i;j++&#123; //j控制列数，是乘法表中的第一个数 fmt.Printf(&quot;%d*%d=%d &quot;,j,i,i*j) &#125; fmt.Println() &#125;&#125;/*1*1=11*2=2 2*2=41*3=3 2*3=6 3*3=91*4=4 2*4=8 3*4=12 4*4=161*5=5 2*5=10 3*5=15 4*5=20 5*5=251*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=361*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=491*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=641*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81*/ 使用循环嵌套来输出1～50中的素数12345678910111213141516171819202122package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;1-50中的素数：&quot;) // 定义局部变量 var a, b int for a=2;a&lt;=50;a++&#123; for b=2;b&lt;=(a/b);b++&#123; if a%b == 0&#123; // 如果发现因子，则不是素数 break &#125; &#125; if b&gt;(a/b)&#123; fmt.Printf(&quot;%d &quot;,a) &#125; &#125;&#125;/*1-50中的素数：2 3 5 7 11 13 17 19 23 29 31 37 41 43 47*/ 3.7 循环控制语句break语句break，跳出循环体。break语句用于终止当前正在执行的for循环，并开始执行循环之后的语句。 1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123; for i:=1;i&lt;100;i++&#123; if i&gt;5&#123; break &#125; fmt.Printf(&quot;%d &quot;,i) &#125; //循环体外部的代码 fmt.Println() fmt.Println(&quot;newline after for loop&quot;)&#125;/*1 2 3 4 5newline after for loop*/ continue语句Go语言的continue语句有点像break语句。但是continue不是跳出循环，而是跳过当前循环，执行下一次循环语句。 for循环中，执行continue语句会触发for增量语句的执行。换言之，continue语句用于跳过for循环的当前迭代，循环将继续到下一个迭代。 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; //打印1-10中的偶数 for i:=1;i&lt;=10;i++&#123; if i%2==1&#123; continue &#125; fmt.Printf(&quot;%d &quot;,i) &#125;&#125;/*2 4 6 8 10*/ break与continue的区别如下: break语句无条件跳出并结束当前的循环，然后执行循环体后的语句。 continue语句跳过当前的循环，而开始执行下一次循环。 goto语句Go语言的goto语句可以无条件地转移到程序指定的行。 goto语句通常与条件语句配合使用。可用来实现条件转移、构成循环、跳出循环体等功能。 但是，在结构化程序设计中一般不建议使用goto语句，以免造成程序流程的混乱，使理解和调试程序都产生困难。 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func main() &#123; var C, c int // 这里不写入for循环是因为for语句执行之初会将C的值变为1， // 当goto A时，for语句会重新执行（不是重新一轮循环） C = 1 LOOP: for C &lt; 50&#123; C++ // C=1 不能写入for这里就不能写入 for c=2;c&lt;C;c++&#123; if C%c == 0&#123; goto LOOP // 若发现因子则不是素数 &#125; &#125; fmt.Printf(&quot;%d &quot;,C) &#125;&#125;/*2 3 5 7 11 13 17 19 23 29 31 37 41 43 47*/","categories":[{"name":"Go","slug":"Go","permalink":"http://www.furadwho.top/categories/Go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.furadwho.top/tags/go/"}]},{"title":"阅后即焚（六）","slug":"阅后即焚（六）","date":"2021-11-05T14:26:46.000Z","updated":"2021-11-07T13:04:41.687Z","comments":true,"path":"2021/11/05/阅后即焚（六）/","link":"","permalink":"http://www.furadwho.top/2021/11/05/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A%EF%BC%88%E5%85%AD%EF%BC%89/","excerpt":"","text":"阅后即焚（六） 应该从哪里说起来呢？我的思绪又不知在一次飞，虚无缥缈，在何处。 今天和小赵相聊甚欢，说了好久好久。虽是 online ，但我想字字情感应该都会带到她的身边，绝无戏言，妄我之意，又何来戏言。那时候很想时光就在那一刻停下来，不要去变化，留下来，似久久树脂滴落，凝固此刻满是欢喜的我，就这样永存下去。 11.06 19:40 “我永远为人类感情里的真挚真诚热烈而感动，如果没办法拥有我将永远为别人热泪盈眶.” ​ —– 题记 这两天下雪了，好久没有看见这样的雪花了，我和小赵出去走了走，也算是赏了这个冬天的第一场雪了。她会给我分享雪后的校园，分享着纷纷落下的秋叶，好久没有这样的日子了。走在了不算上公园的公园里，这里的雪好干净，抖了抖树上的雪堆，落在了她的身上，她稍有些不高兴，但这样子多好！ 小赵追问我高中时候追女生的故事，真的没什么可值得回忆的，脑海里一一想着之前发生的点滴，要是说快乐的事情大概就是这个过程吧！作为一个记性极差的人，能回忆到的几乎就都是心里放不下的苦楚吧，这些我希望它们都会伴着我成长，一点一点地改变我。 “如果她再来联系你，你还会接受吗？” 不会！很坚定！那段日子已经是过去了，带给我的也不是什么美好的回忆，那样的时光已经在心里烙下了痕迹，么有什么必要再去揭开了。再说，那个“傻X”的我也不会回了。 写到这个突然想到今天的一个社死瞬间，去找小赵，她和室友在图书馆的门口打雪仗。不凑巧看到了其中一个同学满身的雪，不凑巧我还好奇了一下，不凑巧一句“这个大姐怎么了，是被推在了雪地里吗？”🤪。淦，当这句“大姐”脱口而出时，察觉了在场所有人，除了我之外的表情。犯错了！讲真，我真的不是故意的。实在抱歉这位同学！🙈 继续说吧。所有的感情经历都会去改变一个人，包括他的想法，他的认知，他对于感情的所有看法，他的世界观，他的爱情观所有所有，都会潜移默化地改变着。小赵问“你想不想问一些关于我的事情？”我的心中是想的，更多的了解一些有关于她的事情。但，我又该怎么说出口呢？或者说，不想去触及一个人的心里软弱之处，有的故事在心中就让它一直放在心中就好了，若是说出会苦恼，便无须去探知了。正因为我在和她相处，应会去尽自己努力学会去了解，自己知道就好了。 怎么说，一种很矛盾的心里！想知道，却又不想了解。按小赵的话来说，水象星座是这样的。有关于星座的看法，在之前有说过我的看法，这里就不提了。 开心的是她还是和我分享了之前的感情经历。早在当初军训的时候，就有听说了一点点关于这件事情。但是，我没想到这个故事是那样的苦楚（不可思议），也不能这样去提及形容，以后有合适的词再说吧！ 这段感情，在我看来，失去了之间的尊重与理解！她愿意为他去改变，去做一些无理由的事情。转头我看着她的眼睛（她的眼睛真的是很好看），想着面前的这个她那时候是那样勇敢，也在这之后慢慢地改变着和坚强，真好！不想过于详细的描述这个事情，在心里知道就可以了。（🙃 题外话，要是有人这样对我，真的无法想象会有多爱她，哈哈哈哈。一个在乎回应的人，有时候一句话就可以，是最好的回答！） 天龙人啊🚬。没有什么可说的，我永远不会如此，就行了，何苦浪费我的笔墨。 话说我不应该在小赵面前爆这么多粗口的，这着实不雅，切记！！！ 昨天我们也聊到了安全感这件事情，这东西真的蛮神奇的，什么是安全感，何种情况是属于缺乏安全感，我还真的去各类软件查询了有关于这个词的分析，说到底，还是看两个人之间的信任程度。当她足够相信一个人会在需要的时候出现，会在需要安慰的时间段来安静的听她说的话，来安慰，会在她需要帮助的时候第一个站出来。让她觉得有人可以依靠，这就是我理解的安全感！但是，这绝非是一个操纵彼此之间感情的完美理由。这个天龙人少爷便做出了如此过分的事情，无法理解和接受。 说了自己的家庭，所接受的教育。怎么说呢，说我自卑呢？我绝不会这样想的，自卑又称为自卑感，是指个人体验到自己的缺点、无能或低劣而产生的消极心态。没有像天龙人一样的家庭环境，没有像朋友一样优越的条件，但我还是不会这样的想，受之于父母，有着自己的好友与死党，他们爱着我们，我们爱着他们，要是论幸福感，至少我是幸福之极的。在当前的整个社会里，似乎“门当户对”成为一种不可避免的前提。我的幸福感在这面前多少会显得脆弱不堪。他们不门当户对，就会没有爱情，会不幸福，会过得很累。错误的前提，两人如果真的相爱，最先的前提无非就是他们之间的话题感，尊重感。交谈不来，互不尊重，又什么意义呢？害，这是多么的矫情，无助的吐槽罢了，不想因此，但必须面对。 🤔关于我自己。不知道在小赵心里我是怎么一个形象，希望是好的，这样就可以了，也不是说什么矫情之举！ 就这样吧。有了想法在说吧，还是和之前一样，附上我喜欢的歌《平凡的一天》。 “不用早起不用熬夜，周围有很多朋友，晚上互相去对方家里，晴天比雨天多。” 开满花的院子， 柔风暖阳， 友人在旁， 笑语绕梁，就是平凡的一天。 每个早晨七点半就自然醒 风铃响起又是一天云很轻 晒好的衣服味道很安心 一切都是柔软又宁静 每个路口花都开在阳光里 小店门前传来好听的恋曲 不用太久就能走到目的地 人来人往里满是善意 这是最平凡的一天啊 你也想念吗 不追不赶慢慢走回家 就这样虚度着年华 没牵挂 只有晚风轻拂着脸颊 日落之前斜阳融在小河里 逛了黄昏市场收获很满意 朋友打来电话说他在等你 见面有聊不完的话题 餐桌摆在开满花的院子里 微微酒意阵阵欢歌笑语 从不考虑明天应该去哪里 因为今夜的风太和煦 这是最平凡的一天啊 你也想念吗 不追不赶慢慢走回家 就这样虚度着年华 没牵挂 只有晚风轻拂着脸颊 这是最完美的一天啊 你也想要吗 生活可以不那么复杂 就这样虚度着年华 没牵挂 只有晚风轻拂着脸颊 总有一天 我们会找到她","categories":[{"name":"阅后即焚","slug":"阅后即焚","permalink":"http://www.furadwho.top/categories/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://www.furadwho.top/tags/emo/"}]},{"title":"Fabric 账号体系","slug":"Fabric-账号体系","date":"2021-11-03T02:50:20.000Z","updated":"2021-11-03T15:58:09.234Z","comments":true,"path":"2021/11/03/Fabric-账号体系/","link":"","permalink":"http://www.furadwho.top/2021/11/03/Fabric-%E8%B4%A6%E5%8F%B7%E4%BD%93%E7%B3%BB/","excerpt":"","text":"Fabric 账号体系Fabric 账号简介Fabric 的账号体系是 Fabric 的重要的组成部分，由于 Fabric 是基于证书而不是传统的户名名和密码形式，所以会有所不同。 在任何非开放系统中都需要通过账号和密码对系统人口进行相关的管理。联盟链的特点是用户非授权时不能接入区块链，所以 Fabric 系统中存在一套授权体系，称为 Fabric 的账号体系。 Fabric 中的账号实际上是根据 PKI 规范生成的一组证书和秘钥文件 。 cryptogen 模块生成的文件中就包含Fabric 账号相关的证书文件，Fabric 中每条交易都会加上发起者的标签（签名证书），同时用发起人的私钥进行加密。如果交易需要其他组织的节点提供背书功能，那么背书节点也会在交易中加入自己的签名。这样每一笔交易的操作过程会非常清晰并且不可篡改。 一个完整的Fabric账号的结构： msp：主要存放签名用的证书文件和加密用的私钥文件 admincerts：管理员证书 cacerts：根CA服务器的证书 keystore：节点或者账号的私钥 signcerts：符合x.509的节点或者用户证书文件 tlscacerts：TLS根CA的证书 tls：存放加密通信相关的证书文件 ca.crt server.crt server.key 基于cryptogen的账户管理体系cryptogen模块是创建Fabric账号的方式之一。cryptogen模块会根据配置文件的定义生成相关数据的配置文件。 cryptogen模块通过一个配合可以部分解决需要引入新的组织，或者组织中需要增加新的账号和用户。 通过 cryptogen 模块 子命令 owtemplate 显示默认的模板。 123456789101112131415161718Orderer rOrgs:Name: OrdererDomain:http://example.comSpecs:Hosename:ordererPeerOrgs: Name:Org1 Domain:http://org1.example.com Template: Count:1 Users: Count:1 Name:Org2 Domain:http://org2.example.com Template: Count:1 Users: Count:1 在配置文件中PerrOrgs节点Template子节点中有个属Count,Count表示当前组织包含Peer节点的数目，同时也会成生成相应数目的配置文件。例子中给出的组织Org1设置的Peer节点数为4，cryptogen模块根据配置文件会给组织Org1生成4个Peer节点所有需要的账号。 https://zhuanlan.zhihu.com/p/106125941 http://www.868qkl.com/jiaocheng/559.html","categories":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://www.furadwho.top/categories/Hyperledger-Fabric/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://www.furadwho.top/tags/Fabric/"}]},{"title":"阅后即焚（五）","slug":"阅后即焚（五）","date":"2021-11-01T12:48:18.000Z","updated":"2021-11-01T14:44:18.706Z","comments":true,"path":"2021/11/01/阅后即焚（五）/","link":"","permalink":"http://www.furadwho.top/2021/11/01/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"","text":"阅后即焚（五） 这是两天的快乐，很快乐！！！！！！！！ 和小赵聊了好久，很开心！十一月了啊，时间过得飞快，有点像是快乐推着过日子。 今天和小陈讨论一下我的近况，说是有点在像吃狗粮，很开心却夹杂着一些算是担忧的东西，自己控制不住的想，倒是有点忧来忧去的意思了。为什么担忧呢？大概有几点吧，其一便是这种日子会持续多久呢？其二她对我感觉呢？其三未来呢？其四，没有了，想不到了。 今天看了陶白白的星座分析，之前我一直是弃之以鼻的，“我命由我不由天”，讲真，星座这东西大多数还是一群的共性特征进行总结，它囊括的点有很多，说的也是很含糊，和算命算我去当兵会有很好的发展一样。挑好的给长辈听，自然万事大吉。转念一想，既然是共性，应该她也会这样吧。 很不巧的事情发生了，我忘记了她的生日。她之前和我说，“你生日我还给你发祝福呢，你没有回我，我记仇了”。老脸一红，现在连的生日都忘记了，真是该死！看了看大致的月份星座，记住了一大堆，一大坨如何。害，去他的，看不下去，她是她，真的如何不都是妄想嘛。 还是很对不住，忘记了生日！淦 和小陈分享，一派胡言乱语，似乎成了长性。但，回想起来之间的故事，想想真的很幸福！ 遛弯，互送礼物，定时闹钟……真一切都是在我的身上发生的吗？我真的有这么幸运吗？在我看来怕是自己疯了，而都是这么真真切的存在着。 关于担忧，不想去想清楚，想明白问题就不是我了。一个巨大的迷宫，身边的一个个物品全都变大，不给我留下一丝空间，抬头看看互相拥挤的出来的缝隙，无法呼吸，头疼欲裂。这是小时的噩梦，我不想。似乎和之前的文笔不尽相似，是我的好心情了。 “慢慢来” 这应该就是我最好的方法，不尽感谢！","categories":[{"name":"阅后即焚","slug":"阅后即焚","permalink":"http://www.furadwho.top/categories/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://www.furadwho.top/tags/emo/"}]},{"title":"Drive my car","slug":"Drive-my-car","date":"2021-10-31T12:49:35.000Z","updated":"2021-10-31T13:02:36.933Z","comments":true,"path":"2021/10/31/Drive-my-car/","link":"","permalink":"http://www.furadwho.top/2021/10/31/Drive-my-car/","excerpt":"","text":"Drive my car always on the way 生き残った二人ははじめて同一フレーム内で距離を無化し、触れあうことになる。幸存下来的两人第一次在同一个框架内消除距离，触碰彼此。 要是问起我看了这个电影有什么感受的话，其实我也有一些搞不清楚。倒是开始对于一直坚信的爱情观念产生出了一些的怀疑，曾以为两个相爱的人都会对于彼此包容以及理解，我有很过分的想法，“如果你不在爱我，就去寻找你的爱情，我不会有一丝的阻拦！”。这部电影里的男主就是这样做的，他发现了妻子的出轨但是他并没有去质问，他相信他们之间的爱情是真挚，深情的。就和我认为的一致，妻子在等待，等待着丈夫的质问，他的愤怒。但是，他没有！“和平常一样地爱她”。 虽然这部电影的核心出发点是背叛，但这个故事真正的精髓在于，我们生活中的任何希望，终归还是来源于彼此相互的信任。 要是问我对于上面的看法怎么想，其实我真有一些搞不清楚了…… 可能就真的是： 在极度失望、极度悲观面前， 人还是要坚忍地生活下去。 今天得知草东的鼓手离开了，第一时间的想法就是他们音乐怎么办，还能听到好的作品吗。看起来真的有一些自私呢！","categories":[{"name":"电影","slug":"电影","permalink":"http://www.furadwho.top/categories/%E7%94%B5%E5%BD%B1/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://www.furadwho.top/tags/%E7%94%B5%E5%BD%B1/"}]},{"title":"内网穿透，外网访问虚拟机web服务","slug":"内网穿透，外网访问虚拟机web服务","date":"2021-10-31T03:00:34.000Z","updated":"2021-10-31T06:03:38.462Z","comments":true,"path":"2021/10/31/内网穿透，外网访问虚拟机web服务/","link":"","permalink":"http://www.furadwho.top/2021/10/31/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%EF%BC%8C%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%BAweb%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"内网穿透，外网访问虚拟机web服务 什么是内网穿透简单的说，就是想要外网访问内网的服务。 内网穿透，即NAT（Network Address Translator）穿透，是指计算机在内网（局域网）内使用私有IP地址，在连接外网（互联网）时使用全局IP地址的技术。该技术被普遍使用在有多台主机但只通过一个公有IP地址访问的私有网络中。 举个例子：配置了一个服务器 Server A，在同一个局域网，就可以通过自己的笔记本使用SSH连接，当不在统一局域网，就没有办法直接使用SSH连接了，这个时候就需要进行NAT穿透，可以使用SSH连接Server A。 NAT原理解析NAT（Network Address Translation，网络地址转换），也叫做网络掩蔽或者IP掩蔽。NAT是一种网络地址翻译技术，主要是将内部的私有IP地址（private IP）转换成可以在公网使用的公网IP（public IP）。 当信息由局域网向因特网传递时，源地址从专有地址转换为公用地址。由路由器跟踪每个连接上的目的地址和端口。 当数据返回路由器时，通过记录的连接跟踪数据来决定该转发给内部网的哪个主机；如果此时如果有多个公用地址可用，当数据包返回时，则会客户机的端口号可以用来分解数据包。 首先NAT路由器将发送源地址从私有IP地址(10.0.0.10)转换为全局的IP地址 (202.244.174.37)再发送数据 当数据从地址163.221.120.9发过来时，NAT路由器将目标地址从原句IP地址(202.244.174.37)先转换成私有IP地址10.0.0.10以后再转发 NAT实现方式及主要类型1.NAT实现方式 1）静态NAT：也就是静态地址转换。是指一个公网IP对应一个私有IP，是一对一的转换，同时注意，这里只进行了IP转换，而没有进行端口的转换。举个栗子： 2）NAPT：端口多路复用技术。与静态NAT的差别是，NAPT不但要转换IP地址，还要进行传输层的端口转换。具体的表现形式就是，对外只有一个公网IP，通过端口来区别不同私有IP主机的数据。再举个栗子。 NAT的主要类型对于NAPT我们主要分为两大类：锥型NAT和对称型NAT。 其中锥型NAT又分：完全锥型，受限锥型和端口受限锥型。 概括的说：对称型NAT是一个请求对应一个端口；锥型NAT（非对称NAT）是多个请求（外部发向内部）对应一个端口，只要源IP端口不变，无论发往的目的IP是否相同，在NAT上都映射为同一个端口，形象的看起来就像锥子一样。下面分别介绍这四种类型及其差异。 client(192.168.0.3, 100)和server(1.1.1.1, 1111)在路由器上建立好映射关系后，如果client(192.168.0.3, 100)又给(2.2.2.2, 2222)发送数据，路由器该怎么处理呢?1231, 复用旧的映射关系(8.8.8.8, 800)&lt;---&gt;(192.168.0.3, 100)和(2.2.2.2, 2222)通信, 这就是锥型(Cone) NAT---（分为下面的3个小类）2, 创建新的映射关系(8.8.8.8, 801)&lt;---&gt;(192.168.0.3, 100)和(2.2.2.2, 2222)通信, 这就是对称型NAT 注: (8.8.8.8, 801)只是举例，到底用什么端口取决于路由器的端口管理策略，总之是另外的一个端口，有的路由器有多个公网IP，不同的IP也会参与到这个映射关系中。 client(192.168.0.3, 100)和server(1.1.1.1, 1111)在路由器上建立好映射关系后，如果这个时候路由器(8.8.8.8)在800端口上收到从另外一台server(2.2.2.2, 2222)发来的数据，是不是应该转发给(192.168.0.3, 100)呢？有四种情况: 12345671, 无条件转发给(192.168.0.3, 100)， 这就是全锥型(Full Cone)NAT。2, 如果(192.168.0.3, 100)之前给(2.2.2.2)发送过数据，则转发， 这就是受限锥型(Restricted Cone)。3, 如果(192.168.0.3, 100)之前给(2.2.2.2, 2222)发送过数据，则转发， 这就是端口受限锥型(Port Restricted Cone)。4, 丢弃报文，拒绝转发, 这就是对称型NAT。 从上面也描述也可以看出，安全性系数, 对称型 &gt; 端口受限锥型 &gt; 受限锥型 &gt; 全锥型 （一）完全圆锥型NAT (Full Cane NAT) 完全圆锥型的NAT,将从同一内部IP地址和端口来的所有请求，都映射到相同的外部IP地址和端口。而且，任何外部主机通过向映射的外部地址发送报文，可以实现和内部主机进行通信。 这是一种比较宽松的策略，只要建立了内部网络的IP地址和端口与公网IP地址和端口的映射关系，则所有Internet上的主机都可以访问该NAT之后的主机！！！ 在图中，对称型NAT会将内网地址{X:y}转换成公网地址{A:b}并绑定为{X:y}|{A:b}&lt;一&gt;{P:q}。这就意味着NAT只允许地址{A:b}接收来自{P:q}的分组，将它转给{X:y} 。当客户机请求一个不同的公网地址{M:n}时，NAT会新分配一个外部端口{C:d} 。 （二）受限圆锥型NAT ( Restricted Cone NAT)–IP受限受限圆锥型NAT也是将从相同的内部IP地址和端口来的所有请求，映射到相同的公网IP地址和端口。 但是与完全圆锥型NAT不同，当且仅当内网主机之前己经向公网主机(假设IP地址为P)发送过数据分组，此公网主机才能够向内网主机发送数据分组。 在图中，NAT会将内网地址{x:y}映射成公网地址{A:b〕并绑定，只有源地址为P的分组才能和此内网主机通信。 （三）端口受限圆锥型NAT ( Port Restricted Cone NAT)–IP+port受限类似于受限圆锥型NAT，但更严格。端口受限圆锥型NAT增加了端口号的限制，当且仅当内网主机之前已经向公网主机发送了数据分组，公网主机才能和此内网主机通信。 在图中，NAT会将内网地址{X:y}映射成公网地址{A:b}并绑定，由于内网主机之前己经分别与地址为M,端口为n的公网主机以及地址为P,端口为q的公网主机通信，所以只有来自这两个公网地址和端口的分组才能到达内网主机。 （四）对称型NAT CSymmetric NAT)—-重点理解对称型NAT把从同一内网地址和端口****到相同的地址和端口的所有请求，都映射到同一个公网地址和端口。 如果同一个内网主机，用相同的内网地址和端口向另一个地址发送数据分组，则会使用不同的映射，而且公网主机只有在接收到数据分组后，才能向与发送分组的内网主机进行通信。可见，对称性NAT是所有NAT类型中限制最为严格的。 在图中，对称型NAT会将内网地址{X:y}转换成公网地址{A:b}并绑定为{X:y}|{A:b}&lt;一&gt;{P:q}。这就意味着NAT只允许地址{A:b}接收来自{P:q}的分组，将它转给{X:y} 。当客户机请求一个不同的公网地址{M:n}时，NAT会新分配一个外部端口{C:d} 。 判断过程1.首先是我们的客户端，向服务端的第一IP地址和端口，发送一个请求;之后服务端回送一个响应（包含客户端的官网IP和端口信息）给客户端。如果回来这个地址（响应信息中获取得到的IP地址）和我们之前发送的地址（NAT内网地址）是一致的，那就是公网的。如果不一致说明我们是在NAT之后，这是第一次检测。**—-检测是公网主机还是位于NAT网关后面的内网主机（不用太考虑下图中的客户端的端口信息）** 2.再接下来就是检测是对称型还是限制性NAT。首先，如左图所示客户端向服务器第一个IP地址发送了一个请求 ，然后再如右图所示，客户端向服务端第二个IP地址发送一个请求。如果两次回复的响应中的主机公网IP地址和端口与上次回来的公网IP地址与端口是不一样的，它就是对称型NAT；如果一样还需要进一步判断。 3.接下来检测是否是完全锥型NAT。是否再接下来就是客户端向服务端第一个IP地址发送了一个请求 ，然后它通过第二个IP地址给我回一个请求，如果可以接收到，就表示为完全椎型，否则不是完全椎型。（不用太考虑下图中的客户端的端口信息） 4.紧接着再发送一个请求到第一个这个地址，那么它用这个地址的第二个端口向我回消息，如果这时候我是能收到的，说明是IP地址限制锥型NAT，如果不能收到说明是端口限制锥型。 以上就是我们NAT检测基本的一个过程。 个人实践总结因为之前使用 Fabric 一直在虚拟机里面使用，就懒得在服务器配置一遍了，然后就想着使用内网穿透的这个方式和他们进行网络测试。就有了两种尝试，上面我也是看别人的整理，感觉还是记录一下，虽然两三天之后就忘记了，但是毕竟方便自己看。 第一种，配置我们的路由器，里面有一个虚拟服务设置，只要配置内网 ip 就可以了，但是很不幸地是我们的网ip好像不是公网ip。导致我完美的配置依旧没有生效。 第二种，就是使用工具，利用一些内网穿透的工具，像什么花生壳…之类的。反正用了工具就是很简单，草。","categories":[{"name":"奇巧淫技","slug":"奇巧淫技","permalink":"http://www.furadwho.top/categories/%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/"}],"tags":[{"name":"http","slug":"http","permalink":"http://www.furadwho.top/tags/http/"}]},{"title":"阅后即焚（四）","slug":"阅后即焚（四）","date":"2021-10-29T06:48:38.000Z","updated":"2021-10-29T13:47:36.305Z","comments":true,"path":"2021/10/29/阅后即焚（四）/","link":"","permalink":"http://www.furadwho.top/2021/10/29/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"阅后即焚（四） 感情这东西很神奇，最近又开始在晚上想很多，想和她的未来，想自己真的可以配上她吗，会有什么样的结果。这种感觉好受也不好受，过着平庸的生活却有着这些很奇妙的幻想啊！ 有时候想些这样的事情，真的好累。 正值秋天，这周的天气真的好棒！每天都有太阳，有微风，拖了把椅子坐在窗前，晒着太阳，傻傻的等待着消息回复。看着窗外的明媚，想着心里的故事，似乎可以一直这样真的很好啊！前两天她和我说，想和我出去溜溜弯，心里很开心，我是一个内敛的人，至少在她的面前是这样的。活脱脱一个闷骚的男生，有的话我真的不知道怎么表达，心里也很珍惜这一段关系，害怕自己的某一句，某一个过分的举动，伤害到了这段感情。 *我视她如珍宝… *🚬 又是这样的一个下午，想着未来，想着一些虚无缥缈。她给我带来的感觉，我不知是否得当，但是要是想描述的话，和我第一次追女生的感觉是一模一样。胆小怯懦，不可言喻。应该是不得当的，至少这样的对比是不值当的。第一次见她是什么样的呢，问自己这个问题，怎么在酒桌上的情场高手，当遇到了却不知道用什么言语来形容了呢？确实，用什么描述呢。那是一场集体活动军训，不是一个专业，学校的安排是不同院系在一起集训。就这样我们被分在了同一个小组里，当看她的第一秒，我就和旁边的好友说道“真好看啊！”没错，很俗套的遇见，被吸引，想表现自己。现在想想，就算记性在不好的我，也觉得很好看！ 枯燥的训练项目，令大家生厌，但她依旧每天带着笑容，我不敢直视，那是心中的太阳！ 在一次的无聊的等待期间，大家玩起了真心话，那也是我第一次和她说话。轮到我说自己的真心话，阐述了高中时候是怎么把女生气哭的，怎么样自己不知所措，就和她坐着一起哭的。描述了自己追高中女孩子，追了三年多依旧没有什么回应的真心话。我也不知道，自己怎么就在那时候说了这些酒桌上的茶余饭后的故事，可能就是想把自己的故事和她分享，让她对于我有点兴趣吧。仅仅这样罢了。 当时她问我“那如果那个女孩子回来找你，你还会怎么样的面对？”，不知道为什么，对于这个问题还是记忆满深刻的，“如果她回来，我依旧会接受，无论她经历了什么”。真的，那时候或者说，半年前我依旧是这样想的，对于那段感情，尽管不美好，我还是不会去忘记。青春的痕迹，不似伤害在身体上留下了痕迹，它在心里让我珍藏。写到这，倒是显得我很渣男了，为什么口头说着喜欢，心里面还在想着另一段的感情？要是这么问，我也不知道应该如何回复了，这就是我吧，对于这些事情，很难遗忘。 不知道我这样回答给了她算是怎么样的感觉，没有在继续问下去了。不在言语了。我想应该到此为止了，毕竟这番话出来应该就是“渣男”石锤了。 后来啊，班长一直怂恿我主动一些，为什么有感觉却不想表达呢？嗯，我害怕！没有什么多余的借口，单单是因为自己害怕。“我这么让你怕吗？”讲真的，还真有一点。这种感觉很奇怪就像是自己心里有什么很柔软的地方，不想展现出来，不想让他们触碰一样！她在我心里一直是如此的完美的，白月光，朱砂痣。我又是一个如此肮脏的人，一直信奉着，“只要两个人互相靠近，就一定会有伤害”。我不想存在这样的伤害，就会主动的离开，不去有什么进一步的关系导致我们的关系如何如何的。这就是我心里怕，以及最为柔软的地方。 在这个时间，我打破了所有的懦弱的想法。曾有朋友对我说“既然你觉得你们之间是存在缘分的，那又为什么选择放弃，选择离开，你不去抓住这份缘分，未来可能真的就再也找不到了！”是很有道理的一段话，我想让自己逐渐变得更好，不想让自己身边的人一个个离开，我想拥她入怀，抓住这份缘分。 命运啊，我真的有多希望你能听到我这番话，帮我一把，从这深渊之中把我救出，得到一份属于自己的爱。不求这份爱的天长地久，珍惜这个过程，就已经很知足了。 回归上文，在班长的鼓励下，那时候我开始和她交流，发现我们的爱好是如何的相似，之间的观念是那么的想像，就好像世界上真的就是在等着她来到一样。过了一段时间，我发现自己有一些无趣，觉得我要是一个女生也会觉得自己很无趣。我是一个保守派，至少这样看来没有什么问题的，不会说话，不会浪漫，不会有什么对于爱意的表达，每天就是问候，聊聊自己的生活。也就是这样了，她会听我的这番唠叨，听我的故事，和我分享她的世界。由此滋生的是我对于自己的复面情绪，对于自己行为一切一切的否认，我一直以来不认为自己是一个“好人”，有很多的很多的毛病，甚至有些小人得志的意味，我想做一个真正的自己，却一直不能做成自己。只能越发觉得自己真的有一些差劲。 选择了逃离，这是我常用的一个办法了，“逃避虽然可耻，但是却很有效果”。我选择了淡出她的世界，看来也就是这个程度了，也就到这了，在她的心里应该算是留下一个好的印象，就这样的不体面的不辞而别。我不在联系她，那时候的想法真的很多单纯，愚蠢。 我想有一个人和我聊聊天说说话，和我分享她的生活，她的世界。但是，我却在刚有起色的时候，选择了逃离。 什么狗屁想法，这一切的来源只不过全是我自己罢了，自作自受罢了。 没有什么华丽的词藻，只是很平淡地把自己内心的一切想法，一五一十地全全托出。我喜欢听毛不易的《平凡的一天》，那是我真的渴求的日子，平平凡凡地度过自己的生活，就是仅仅而已。 之前的一些故事到这里大致就一一告落了，我和她在那时就没有什么了联系，开始了结束了一场由自己主导主演的电影，也认清了自己的软弱。这场称不上喜剧还是悲剧的故事，一顿操作下，没有了结尾。 前些日子她突然找我问一个学校的问题，那个时候，我想起了以前的日子，一段没有结束的日子。我想应该好好地面对自己了，真心地去面对她了。再一次开始了和她的联系，我想紧紧地抓住这份缘分，这次我不会想有没有什么结果了，我只想和她好好地做一次朋友，做一次真正的自己，直视自己，直视她，表达自己的想法感觉。 一点点地变化，一点点地不敷衍回复一个“确实”，一点点地和她分享我的生活，一点点地了解她的生活。一开始我还有点控制不住自己的感情，想把整个人都拿出来让她了解，感谢她的理性，感谢她对于我的一些问题的指出，这么说起来倒是有一点老师的感觉了。也确实这样的感觉，目前我觉得很棒！我不能有什么奢望，不是害怕得不到什么回馈，我真的真的只是害怕失去这个朋友，失去这个和我聊得来的人…… ​ 写出来这么多，心里也真是很舒服呢，就到这里吧，变成一个更好的自己，让她接受的一个自己。 晚安，好梦！☽ 用一首歌词作为结尾吧！ And when i think当我想起 of everything that we did together那些我们一起的时光 Somewhere in Verona在维罗那的某处 The sun set over our time together一起度过日落时分 Thinking it over几番回想 So young and sentimental如此年轻，如此多情 Our hearts so gentle我们的心却是那么温柔 Such a shame we had to drift apart多遗憾我们不得不渐行渐远 Oh…Oh… but I can’t help just wonder总情不自禁地去想 Could we really last forever?我们能一直走下去吗 I watch the sunset and something’s telling me that I gotta get up and chase it我看着日落，某种声音告诉我，我得奋起去追逐 Day of transit车上奔波的一天 The gentle weight of your head on my shoulder感受你将头轻轻靠在我肩膀上的重量 I wake you at the last stop在最后一站把你唤醒 Your sleepy eyes in the gloomy weather阴郁天气里，你惺忪的睡眼 Raining in Florence佛罗伦萨那场雨 Your cold hands and your wet hair你冰凉的手掌和淋湿的头发 While we’re cursing我们抱怨着 Cheap umbrellas trying to get home撑着廉价的雨伞想要赶回家 Now we’re written in history现在那都是我们的回忆了 We close the book we opened up我们打开了这本书，又亲手把它合上 There will always be a place in my heart但我的心里永远有一块位置属于你 But baby can’t you see we were meant to fall apart…亲爱的，难道你不知道我们注定要分离… We gave it up我们放弃了 Who would have thought love wasn’t enough谁又能曾想到，只有爱是不够的 In the end we’d say:最终我们只能告别 “Bye my love, guess I’ll see you someday…”再见了，我的爱，可能某天我们还会遇见…","categories":[{"name":"阅后即焚","slug":"阅后即焚","permalink":"http://www.furadwho.top/categories/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://www.furadwho.top/tags/emo/"}]},{"title":"docker 学习","slug":"docker-学习","date":"2021-10-27T07:31:13.000Z","updated":"2021-10-28T04:28:29.609Z","comments":true,"path":"2021/10/27/docker-学习/","link":"","permalink":"http://www.furadwho.top/2021/10/27/docker-%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.furadwho.top/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.furadwho.top/tags/docker/"}]},{"title":"我奶奶都懂 HTPPS","slug":"我奶奶都懂-HTPPS","date":"2021-10-26T06:45:51.000Z","updated":"2021-10-31T03:02:25.222Z","comments":true,"path":"2021/10/26/我奶奶都懂-HTPPS/","link":"","permalink":"http://www.furadwho.top/2021/10/26/%E6%88%91%E5%A5%B6%E5%A5%B6%E9%83%BD%E6%87%82-HTPPS/","excerpt":"","text":"我奶奶都懂HTTPS HTTPS 概述HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。 就是在 HTTP 之下加进去了 SSL ，HTTPS 的安全基础就是 SSL 。 因此加密的详细内容就需要SSL HTTPS: URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。 HTTP默认采用80作为通讯端口，对于传输采用不加密的方式；HTTPS默认采用443，对于传输的数据进行加密传输。目前主流的网站基本上开始默认采用HTTPS作为通信方式。 对称加密对称加密算法的加密和解密都是用同一个密钥。 如果通信双方都各自持有同一个密钥，且没有别人知道，则两方的通信安全是可以被保证的（除非密钥被破解）。 然而，最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。如果由服务器生成一个密钥并传输给浏览器，这个传输过程中密钥被别人劫持，之后他就能用密钥解开双方传输的任何内容。如果浏览器内部预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的。这样，浏览器只要预存好世界上所有HTTPS网站的密钥就可以了。显然，这样做是不现实的。怎么办？解决这个问题，我们就需要非对称加密。 非对称加密非对称加密算法需要一组密钥对，分别是公钥和私钥，这两个密钥是成对出现的。 公钥加密的内容需要对应的私钥解密，私钥加密的内容需要对应的公钥解密。私钥由服务器自己保存，公钥发送给客户端。 客户端拿到公钥后可以对请求进行加密后发送给服务端，这时候就算中间被截获，没有私钥也无法解密发送的内容，这样确保了客户端发送到服务端数据的安全。 非对称加密改良 通过一组公钥私钥，已经可以保证单个方向传输的安全性，那用两组公钥私钥，是不是就能保证双向传输都安全了？请看下面的过程： 某网站拥有用于非对称加密的公钥A1、私钥A2；浏览器拥有用于非对称加密的公钥B1、私钥B2。 浏览器向网站服务器请求，服务器把公钥A1明文传输给浏览器。 浏览器把公钥B1明文传输给服务器。 之后浏览器向服务器传输的所有东西都用公钥A1加密，服务器收到后用私钥A2解密。由于只有服务器拥有私钥A2进行解密，所以能保证这条数据的安全。 服务器向浏览器传输的所有东西都用公钥B1加密，浏览器收到后用私钥B2解密。同上也可以保证这条数据的安全。 可见确实可行。抛开这里面仍有的漏洞不谈（下文会讲），HTTPS的加密却没使用这种方案，为什么？最主要的原因是非对称加密算法非常耗时，特别是加密解密一些较大数据的时候有些力不从心。而对称加密快很多。那我们能不能运用非对称加密的特性解决前面提到的对称加密的问题？ 非对称加密 + 对称加密 既然非对称加密耗时，我们考虑是否可以采用非对称加密+对称加密结合的方式，而且要尽量减少非对称加密的次数。非对称加密、解密各只需一次的方法： 某网站拥有用于非对称加密的公钥A1、私钥A2。 浏览器向网站服务器请求，服务器把公钥A1明文给传输浏览器。 浏览器随机生成一个用于对称加密的密钥X，用公钥A1加密后传给服务器。 服务器拿到后用私钥A2解密得到密钥X。 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密即可。 HTTPS基本就是采用了这种方案。但还是有漏洞的。 中间人攻击 中间人的确无法得到浏览器生成的对称密钥X，这个密钥本身被公钥A1加密，只有服务器才能用私钥A2进行解密。然而中间人却完全不需要拿到私钥A2就能劫持信息，请看： 某网站拥有用于非对称加密的公钥A1、私钥A2。 浏览器向网站服务器请求，服务器把公钥A1明文传输给浏览器。 中间人劫持到公钥A1，保存下来，把数据包中的公钥A1替换成自己伪造的公钥B1（它当然也拥有公钥B1对应的私钥B2）。 浏览器随机生成一个用于对称加密的密钥X，用公钥B1（浏览器不知道公钥被替换了）加密后传给服务器。 中间人劫持后用私钥B2解密得到密钥X，再用公钥A1加密后传给服务器。 服务器拿到后用私钥A2解密得到密钥X。 这样在双方都不会发现异常的情况下，中间人得到了对称密钥X。根本原因是浏览器无法确认自己收到的公钥是不是网站自己的。那么下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？ 数字证书现实生活中，如果想证明某身份证号一定是小明的，怎么办？看身份证。这里政府机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中也有这么一个公信机构，CA 机构。 网站在使用HTTPS前，需要向“CA机构”申请颁发一数字证书，数字证书里有证书持有者、证书持有者的公钥等信息。服务器把证书传输给浏览器，浏览器从证书里取公钥就可以了。然而这里又有一个显而易见的问题：证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？数字证书怎么防伪呢？ 服务器提交自己的基本信息想CA机构提出申请，CA机构在给服务器颁发证书的时候，会连同数字证书以及根据证书计算的摘要一同发送给服务器，且这个摘要是需要经过CA机构自己的私钥进行加密的。申请流程如下： 数字签名我们把证书内容生成一份“签名”，比对证书内容和签名是否一致就能察觉是否被篡改。这种技术就叫数字签名。下图中左侧是数字签名的制作过程，右侧是验证过程 数字签名的制作过程： CA拥有非对称加密的私钥和公钥。 CA对证书明文信息进行hash。 对hash后的值用私钥加密，得到数字签名。 明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包） 浏览器验证过程： 拿到证书，得到明文T1，数字签名S1。 用CA机构的公钥对S1解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S2。 用证书里说明的hash算法对明文T1进行hash得到T2。 比较S2是否等于T2，等于则表明证书可信。 这里需要注意一点，一个是CA的公钥，内置在客户端，用来解密数字签名！另一个是目标服务器的公钥，在数字证书内容里，用来协商对称密钥！ 为什么这样可以证明证书可信？假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。 既然不可能篡改，那如果整个证书被掉包呢？假设有另一个网站B也拿到了CA机构认证的证书，它想搞垮网站A，想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，会导致上文提到的漏洞。其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。 制作数字签名时为什么需要hash一次？最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加密解密就会快很多。当然除此之外也有安全上的原因。 HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？用session就可以。服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了 HTTPS 工作原理 client向server发送请求https://baidu.com，然后连接到server的443端口。 服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。 传送证书这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。 客户端解析证书这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（密钥）。然后用证书对该随机值进行加密。 传送加密信息这部分传送的是用证书加密后的密钥（随机值），目的就是让服务端得到这个密钥（随机值），以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务端加密信息服务端用私钥解密，得到了客户端传过来的密钥（随机值），然后把内容通过该值进行对称加密。 传输加密后的信息这部分信息是服务端用密钥（随机值）对称加密后的信息，可以在客户端被还原。 客户端解密信息客户端用之前生成的密钥（随机值）解密服务端传过来的信息，于是获取了解密后的内容。 自签名证书 和 SpringBoot单双向认证配置及测试下载和安装OpenSSL下载其他人做的便捷版安装包 http://slproweb.com/products/Win32OpenSSL.html 配置环境变量配置环境变量，老生常谈，这里简单贴一下配置OPENSSL_HOME 测试命令： 1openssl version 生成根证书私钥12345678openssl genrsa -aes256 -out private/cakey.pem 1024命令含义如下：genrsa 使用RSA算法产生私钥-aes256 使用256位密钥的AES算法对私钥进行加密-out 输出文件的路径1024 指定私钥长度 生成证书请求（ca.csr)12345678910openssl req -new -key private/cakey.pem -out private/ca.csr -subj “/C=CN/ST=ZHEJIANG/L=HANGZHOU/O=TEST/OU=mygroup/CN=TEST”该命令含义如下：req 执行证书签发命令-new 新证书签发请求-key 指定私钥路径-out 输出的csr文件的路径-subj 证书相关的用户信息(subject的缩写)备注：这里需要输入私钥密码； 检查证书请求信息1openssl req -text -in ca.csr -noout 自签发根证书1234567891011openssl x509 -req -days 365 -sha1 -extensions v3_ca -signkey private/cakey.pem -in private/ca.csr -out certs/ca.cer该命令的含义如下：x509 生成x509格式证书-req 输入csr文件-days 证书的有效期（天）-sha1 证书摘要采用sha1算法-extensions 按照openssl.cnf文件中配置的v3_ca项添加扩展-signkey 签发证书的私钥-in 要输入的csr文件-out 输出的cer证书文件 其他操作： https://www.cxyzjd.com/article/skytering/103247128 SpringBoot配置文件： 123456server.port=443server.ssl.enabled=trueserver.ssl.key-store= src/main/resources/server.jksserver.ssl.key-store-password=Lzr20000306server.ssl.key-store-type=JKS 测试： 1、如果客户端想验证服务端证书，客户端需要安装服务端的公钥文件(cer)(或者服务端证书是官方CA颁发的，客户端可以直接联网认证)，因为服务端会将自己的随机数等信息使用自己的私钥加密之后发给客户端，而客户端要想解开这些数据，必须持有服务端的公钥才可以，之后服务端验证通过。 2、服务端想验证客户端证书，则需要将客户端的证书的公钥文件放到服务端trustStore信任库中，当客户端请求访问服务端时，会使用自己的私钥加密随机数、ssl版本等信息发送给服务端，服务端只有持有客户端的公钥才能解开这些数据，验证才能通过。 相关概念： 1.kestore(密钥库)和truststore(信任库)的区别： ​ Keystore，用来存放服务端证书，可以看成一个放key的库，key就是公钥，私钥，数字签名等组成的一个信息。 ​ Truststore是放服务端信任的客户端证书的一个store，里存放的是只包含公钥的数字证书，代表了可以信任的客户端证书， 而keystore是包含私钥的。 2.证书文件 – cer文件和pfx文件的区别 https://www.cnblogs.com/lthxk-yl/archive/2013/06/03/3115273.html 作为文件形式存在的证书一般有这几种格式： 1)、带有私钥的证书 ​ 由Public Key Cryptography Standards #12，PKCS#12标准定义，包含了公钥和私钥的二进制格式的证书形式，以pfx作 为证书文件后缀名。 2)、二进制编码的证书 ​ 证书中没有私钥，只包含公钥，DER 编码二进制格式的证书文件，以cer作为证书文件后缀名。 3)、Base64编码的证书 ​ 证书中没有私钥，只包含公钥，BASE64 编码格式的证书文件，也是以cer作为证书文件后缀名。 链接： https://blog.csdn.net/weixin_41917987/article/details/80988197?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control","categories":[{"name":"奇巧淫技","slug":"奇巧淫技","permalink":"http://www.furadwho.top/categories/%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/"}],"tags":[{"name":"http","slug":"http","permalink":"http://www.furadwho.top/tags/http/"}]},{"title":"阅后即焚（三）","slug":"阅后即焚（三）","date":"2021-10-26T05:29:41.000Z","updated":"2021-10-27T11:59:45.781Z","comments":true,"path":"2021/10/26/阅后即焚（三）/","link":"","permalink":"http://www.furadwho.top/2021/10/26/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"阅后即焚（三） 人啊！还是得学习，每一个人可能学习的条件，学习得快慢，学习的时间，都是不一样的。但是，我觉得只要是在学习，应该就不负此生了！ 最近，我发现自己真的有点想家了，和家人一视频通话就会两个多小时，没什么话了也不想挂断。真脆弱啊！","categories":[{"name":"阅后即焚","slug":"阅后即焚","permalink":"http://www.furadwho.top/categories/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://www.furadwho.top/tags/emo/"}]},{"title":"Fabric-Go-SDk 学习（一）","slug":"Fabric-Go-SDk-学习（一）","date":"2021-10-25T13:41:36.000Z","updated":"2021-10-26T01:07:32.445Z","comments":true,"path":"2021/10/25/Fabric-Go-SDk-学习（一）/","link":"","permalink":"http://www.furadwho.top/2021/10/25/Fabric-Go-SDk-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"Fabric-Go-SDk 学习（一） 前言因为最近公司让我去学习 Hyperledger Fabric 并且用这个玩应儿和他的 Go SDK 做一个区块链浏览器，所以就有了这一阶段的学习。惯例吐槽一顿，按理说，Fabric本身都是用 Golang 开发的，那么 fabric-sdk-go 作为其亲儿子，功能应该是最为完善的，哈哈哈，事与愿违，Golang 版本的 sdk 反而是最不完备的，开发进度滞后，功能缺失。只能说，文档全是代码，一句介绍就完事了，真是有够简介的呢，草！ 网上有较多的学习方式都是借鉴 nodejs 版本的 sdk ，但是，我也没有深入的学习了解。换句话来说就是，有什么需求，我就去完成什么样的功能，石锤的工具人了! 大致说明GO SDK 还有很多的包，包里面也有乱七八糟的功能： pkg/fabsdk：主 package，主要用来生成 fabsdk 以及各种其他 pkg 使用的 option context (上下文)， 这些上下文由下面列出的客户端软件包使用。 pkg/client/channel：主要用来调用、查询链码，或者注册链码事件，提供频道交易相关功能。 pkg/client/resmgmt：主要用来 fabric 网络的管理，比如创建、加入通道，安装、实例化和升级链码。 pkg/client/event：配合 channel 模块来进行链码事件注册和过滤。 pkg/client/ledger：主要用来账本的查询，查询区块、交易、配置等。 pkg/client/msp：主要用来管理 fabric 的成员关系，身份管理相关功能。 一般情况的时候，使用这几个包就差不多完事了，够用！ 大致开发流程 使用配置实例化 fabsdk 实例。 使用 fabsdk 实例，基于用户和组织创建上下文 使用 New func 创建客户端实例，传递上下文。 使用每个客户提供的功能。 调用 fabsdk.Close（）来释放资源和缓存。 用官网给的一个例子： 1234567891011121314151617181920func TestLedgerClientQueries(t *testing.T) &#123; // Using shared SDK instance to increase test speed. sdk := mainSDK testSetup := mainTestSetup //prepare contexts org1AdminChannelContext := sdk.ChannelContext(testSetup.ChannelID, fabsdk.WithUser(org1AdminUser), fabsdk.WithOrg(org1Name)) // Ledger client client, err := ledger.New(org1AdminChannelContext) if err != nil &#123; t.Fatalf(&quot;Failed to create new resource management client: %s&quot;, err) &#125; ledgerInfo, err := client.QueryInfo() if err != nil &#123; t.Fatalf(&quot;QueryInfo return error: %s&quot;, err) &#125; ......&#125; 就可发现真的很好的说明了上面的过程，good！ Go SDK 包的学习只是一个大概的说明，具体的功能还是直接去查官网。 pkg/fabsdk fabsdk 包说明主 package，主要用来生成 fabsdk 以及各种其他 pkg 使用的 option context (上下文)， 这些上下文由下面列出的客户端软件包使用。 官网：https://pkg.go.dev/github.com/hyperledger/fabric-sdk-go@v1.0.0/pkg/fabsdk 变量 var ErrAnonymousIdentity = errors.New(&quot;missing credentials&quot;) ：当身份创建选项既不包含用户名也不包含身份时，将返回ErrAnonymousIdentity。 类型 ContextOption1type ContextOption func(s *identityOptions) error type ContextOption func(s *identityOptions) error: ContextOption：提供用于创建会话的参数（主要来自结构标识/用户）。 func WithIdentity(signingIdentity msp.SigningIdentity) ContextOption： WithIdentity 使用预先构造的身份对象作为会话的凭证。 func WithOrg(org string) ContextOption： WithOrg 使用指定的组织。 func WithUser(username string) ContextOption：WithUser 使用指定用户加载标识/身份。 类型 FabricSDK123type FabricSDK struct &#123; // contains filtered or unexported fields&#125; FabricSDK 为 SDK 管理的客户端提供访问（和上下文）。 func New(configProvider core.ConfigProvider, opts ...Option) (*FabricSDK, error)： New 根据提供的选项集初始化 SDK ， ConfigOptions提供应用程序配置。 func (sdk *FabricSDK) ChannelContext(channelID string, options ...ContextOption) contextApi.ChannelProvider：ChannelContext 创建并返回频道上下文。 func (sdk *FabricSDK) Close()：关闭释放 SDK 维护的缓存和连接。 func (sdk *FabricSDK) Config() (core.ConfigBackend, error)：Config 返回所有 SDK 配置类型使用的配置后端。 func (sdk *FabricSDK) Context(options ...ContextOption) contextApi.ClientProvider： Context 创建并返回具有所有必需提供者的上下文客户端。 类型 Option1type Option func(opts *options) error type Option func(opts *options) error：选项配置 SDK。 func WithCorePkg(core sdkApi.CoreProviderFactory) Option：WithCorePkg 将核心实现注入 SDK。 func WithCryptoSuiteConfig(cryptoConfigs ...interface&#123;&#125;) Option： WithCryptoSuiteConfig 向 SDK 注入。CryptoSuiteConfig 接口，它接受 CryptoSuiteConfig 的完整接口或每个实现 CryptoSuiteConfig 的一个（或多个）功能的子接口列表。 func WithEndpointConfig(endpointConfigs ...interface&#123;&#125;) Option：WithEndpointConfig 向 SDK 注入EndpointConfig 接口，它接受 EndpointConfig 的完整接口或每个实现 EndpointConfig 的一个（或多个）功能的子接口列表。 func WithIdentityConfig(identityConfigs ...interface&#123;&#125;) Option： WithIdentityConfig 向 SDK 注入IdentityConfig 接口，它接受 IdentityConfig 的完整接口或每个实现 IdentityConfig 的一个（或多个）功能的子接口列表。 func WithLoggerPkg(logger api.LoggerProvider) Option： WithLoggerPkg 将日志记录器实现注入到 SDK 中。 func WithMSPPkg(msp sdkApi.MSPProviderFactory) Option： WithMSPPkg 将 MSP 实现注入 SDK。 func WithServicePkg(service sdkApi.ServiceProviderFactory) Option： WithServicePkg 将服务实现注入 SDK。 pkg/client/channel channel 包说明主要用来调用、查询链码，或者注册链码事件，提供频道交易相关功能。 官网：https://pkg.go.dev/github.com/hyperledger/fabric-sdk-go@v1.0.0/pkg/client/channel 允许访问 Fabric 网络上的通道。通道客户端实例提供了一个处理程序来与指定通道上的对等点进行交互。通道客户端可以在特定通道上查询链码、执行链码和注册/取消注册链码事件。需要与多个通道交互的应用程序应该为每个通道创建一个单独的通道客户端实例。 类型 Client123type Client struct &#123; // contains filtered or unexported fields&#125; 客户端可以访问Fabric网络上的通道。通道客户端实例提供处理程序以与指定通道上的对等方交互。 需要与多个通道交互的应用程序应为每个通道创建一个单独的通道客户端实例。 通道客户端仅支持非管理功能。 func New(channelProvider context.ChannelProvider, opts ...ClientOption) (*Client, error)：New 返回一个 Client 实例。通道客户端可以在特定通道上查询链码、执行链码和注册/取消注册链码事件。 func (cc *Client) Execute(request Request, options ...RequestOption) (Response, error)：Execute （执行）使用请求和可选请求选项准备和执行事务。参数：请求包含有关强制链代码ID和功能的信息， options 包含可选的请求选项。返回：来自 peer 的提案回复。 func (cc *Client) InvokeHandler(handler invoke.Handler, request Request, options ...RequestOption) (Response, error)：InvokeHandler （调用处理程序）使用提供的请求和可选请求选项来调用处理程序。参数：要调用的处理程序，请求包含有关强制链代码 ID 和功能的信息，options 包含可选的请求选项。返回：来自peer的提案回复。 func (cc *Client) Query(request Request, options ...RequestOption) (Response, error)：Query （查询）使用请求和可选请求选项查询链代码。参数：请求包含有关强制链代码 ID 和功能的信息，options 包含可选的请求选项。返回：来自peer的提案回复。 func (cc *Client) RegisterChaincodeEvent(chainCodeID string, eventFilter string) (fab.Registration, &lt;-chan *fab.CCEvent, error)：RegisterChaincodeEvent（注册链码事件）注册链代码事件。 不再需要注册时，必须调用取消注册。参数：chaincodeID 是要为其接收事件的链代码 ID ，eventFilter 是要为其接收事件的 chaincode 事件过滤器（正则表达式）。返回：注册和用于接收事件的频道。 调用取消注册时，通道将关闭。 func (cc *Client) UnregisterChaincodeEvent(registration fab.Registration)：UnregisterChaincodeEvent（注销链码事件）删除给定的链码事件注册并关闭事件通道。参数：RegisterChaincodeEvent 方法返回的句柄。 类型 RequestOption1type ClientOption func(*Client) error ClientOption 描述了 New 构造函数的功能参数 类型 Request1234567891011121314151617type Request struct &#123; ChaincodeID string Fcn string Args [][]byte TransientMap map[string][]byte // InvocationChain contains meta-data that&#x27;s used by some Selection Service implementations // to choose endorsers that satisfy the endorsement policies of all chaincodes involved // in an invocation chain (i.e. for CC-to-CC invocations). // Each chaincode may also be associated with a set of private data collection names // which are used by some Selection Services (e.g. Fabric Selection) to exclude endorsers // that do NOT have read access to the collections. // The invoked chaincode (specified by ChaincodeID) may optionally be added to the invocation // chain along with any collections, otherwise it may be omitted. InvocationChain []*fab.ChaincodeCall IsInit bool&#125; Request 包含查询和执行调用事务的参数。 类型 RequestOption1type RequestOption func(ctx context.Client, opts *requestOptions) error 每个 Opts 参数的 RequestOption func。 func WithBeforeRetry(beforeRetry retry.BeforeRetryHandler) RequestOption：WithBeforeRetry （重试前）指定在重试尝试之前调用的函数。 func WithChaincodeFilter(ccFilter invoke.CCFilter) RequestOption：WithChaincodeFilter （链码过滤器）添加了一个链代码过滤器，用于计算额外的背书人。 func WithParentContext(parentContext reqContext.Context) RequestOption：WithParentContext（带父上下文）封装了 grpc 父上下文。","categories":[{"name":"Go","slug":"Go","permalink":"http://www.furadwho.top/categories/Go/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://www.furadwho.top/tags/Fabric/"}]},{"title":"阅后即焚（二）","slug":"阅后即焚（二）","date":"2021-10-25T06:28:43.000Z","updated":"2021-10-25T06:34:57.035Z","comments":true,"path":"2021/10/25/阅后即焚（二）/","link":"","permalink":"http://www.furadwho.top/2021/10/25/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"阅后即焚（二） 相寻梦里路，飞雨落花中。 —— 晏几道 很满足现在的生活，虽然因为疫情导致不能够去自己想去的地方。但是，似乎每天就这样的和舒服的人一起聊聊天，吹吹牛逼，也是真的不错。昨天晚上做了美梦，好久没有像现在记住这个梦很清晰的感觉了，只能说“小小美梦，大大知足”了。我不算什么大报复的人，只想着平平淡淡就好了……","categories":[{"name":"阅后即焚","slug":"阅后即焚","permalink":"http://www.furadwho.top/categories/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://www.furadwho.top/tags/emo/"}]},{"title":"Xshell、Idea与虚拟机Ubuntu连接","slug":"Xshell、Idea与虚拟机Ubuntu连接","date":"2021-10-23T16:31:39.000Z","updated":"2021-10-24T01:35:09.509Z","comments":true,"path":"2021/10/24/Xshell、Idea与虚拟机Ubuntu连接/","link":"","permalink":"http://www.furadwho.top/2021/10/24/Xshell%E3%80%81Idea%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E8%BF%9E%E6%8E%A5/","excerpt":"","text":"Xshell、Idea与虚拟机Ubuntu连接一、安装 Ubuntu 虚拟机默认VMware的网路是NAT模式，保持不变即可。获取宿主机以及虚拟机 IP 地址。 二、建立 IP 映射将宿主机和虚拟机的IP映射起来。 打开VMware的虚拟网络编辑器（编辑&gt;虚拟网络编辑器）： 选择 VMnet8 ，点击更改设置 选择 VMnet8 ，点击 NAT 设置 点击添加 主机端口，填写默认 22 即可 填入之前查到的虚拟机 IP 地址 虚拟机端口，填写默认的 22 即可 相当于将 宿主机 IP （192.168.80.106:22） 与虚拟机 IP （192.168.240.129:22) 建立起了映射关系。 三、配置虚拟机SSH 安装openssh-client：sudo apt-get install openssh-client 安装openssh-server：sudo apt-get install openssh-server 启动ssh-server：sudo /etc/init.d/ssh restart 确认ssh-server工作正常：netstat -tpl （看到ssh表示工作正常） 四、配置虚拟机防火墙启用22端口并重启防火墙： 12$ firewall-cmd --permanent --add-port=22/tcp $ firewall-cmd --reload 或者直接关闭防火墙： 1$ systemctl stop firewalld.service 五、使用 shell 连接虚拟机 六、配置 Idea 连接虚拟机在 Idea 上面点击如下菜单：Tools—Deployment—Configuration… 新增一台虚拟机，输入名称，选择SFTP协议，输入IP地址、代码路径、账号密码，点击OK 点击Tools—Deployment—Browse RemoteHost 右侧会出现对应的代码路径，修改完代码之后，可以点击右上角的upload图标，将代码上传到虚拟机 点击Tools—Start SSH session…可以打开远程界面 结语这样就可以在宿主机连接到虚拟机进行代码编辑，并且上传了。","categories":[{"name":"奇巧淫技","slug":"奇巧淫技","permalink":"http://www.furadwho.top/categories/%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://www.furadwho.top/tags/ubuntu/"}]},{"title":"《鲨鱼：起点》二刷","slug":"《鲨鱼：起点》二刷","date":"2021-10-23T12:55:26.000Z","updated":"2021-10-23T13:57:09.346Z","comments":true,"path":"2021/10/23/《鲨鱼：起点》二刷/","link":"","permalink":"http://www.furadwho.top/2021/10/23/%E3%80%8A%E9%B2%A8%E9%B1%BC%EF%BC%9A%E8%B5%B7%E7%82%B9%E3%80%8B%E4%BA%8C%E5%88%B7/","excerpt":"","text":"鲨鱼：起点 샤크: 더 비기닝 (2021)之前片荒的时候无意之中找到的一部韩国片子（还是漫改的），说实话，真论敢拍的话还得数大韩人民的电影。 从一开始的入坑韩国灾难片系列，像《流感》《潘多拉》之类，还有那些黑涩会片子，马东锡这种我觉得无敌的。就很少有觉得比较可以戳我点的韩国电影了。 这部片子总体上来说，故事情节也算是老套了。一个高中生因“校园霸凌”戳了对头的右眼，郎当入狱，被判了一个“杀人未遂”。同时，这不巧了，监狱里面有一个全国拳击冠军“哥”，在“哥”的带领之下，男主逐渐变得强大，一路打怪升级，最后打赢了对头。这种剧情确实感觉都已经被拍烂了，回想我当初为什么被这个片子戳到了，一方面应该就是韩国片的敢拍程度，真的算得上“拳拳到肉了”，相比于《悲伤》《少年的你》露骨程度已经超出了几个维度了。 在就可能是当时觉得，自己可能有的时候和里面的男主有点相似，不能说“校园霸凌”，只是觉得自己也想变得“强大”，至少不被人欺负，“想好好地做一个平凡人”。有的时候觉得，在当今这个社会，平平淡淡真的也是蛮难的。应该很多人都深有这种感受吧！所求平淡，又何来“平淡”…… 片子里面有一句，算是最戳动我： 鲨鱼因为没有鱼鰾，只要一刻不游动就会沉下去死掉 所以从出生到死亡，都要一刻不停地游动，不要停下！ Over……","categories":[{"name":"电影","slug":"电影","permalink":"http://www.furadwho.top/categories/%E7%94%B5%E5%BD%B1/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://www.furadwho.top/tags/%E7%94%B5%E5%BD%B1/"}]},{"title":"学了两个月，什么是区块链","slug":"学了两个月，什么是区块链","date":"2021-10-23T07:05:01.000Z","updated":"2021-10-23T10:46:40.493Z","comments":true,"path":"2021/10/23/学了两个月，什么是区块链/","link":"","permalink":"http://www.furadwho.top/2021/10/23/%E5%AD%A6%E4%BA%86%E4%B8%A4%E4%B8%AA%E6%9C%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BA%E5%9D%97%E9%93%BE/","excerpt":"","text":"","categories":[{"name":"区块链","slug":"区块链","permalink":"http://www.furadwho.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://www.furadwho.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"Git 常用操作","slug":"Git-常用操作","date":"2021-10-22T02:10:53.000Z","updated":"2021-10-29T11:24:10.682Z","comments":true,"path":"2021/10/22/Git-常用操作/","link":"","permalink":"http://www.furadwho.top/2021/10/22/Git-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Git 常用操作比较常用的一些 Git 操作，但是日常只需要记住几个就可以。最近实习公司里面一直使用的 SVN ，但是我还是更偏向 Git 这个工具，怎么说呢，能有个地方放着就行了，哈哈哈 几个专用名词： Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 Git 学习Git是一个分布式版本管理系统，是为了更好地管理Linux内核开发而创立的。 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加 / 删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223242526272829# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all# merge 用merge的git路线是跳跃的，如果版本回退你也找不到自己想要的版本$ git pull = git fetch + git merge FETCH_HEAD # 使用rebase操作会更好一点，这样可以线性的看到每一次提交，并且没有增加提交节点$ git pull --rebase = git fetch + git rebase FETCH_HEAD 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他12# 生成一个可供发布的压缩包$ git archive 执行 git fetch origin master 时，它的意思是从名为 origin 的远程上拉取名为 master 的分支到本地分支 origin/master 中。既然是拉取代码，当然需要同时指定远程名与分支名，所以分开写。 执行 git merge origin/master 时，它的意思是合并名为 origin/master 的分支到当前所在分支。既然是分支的合并，当然就与远程名没有直接的关系，所以没有出现远程名。需要指定的是被合并的分支。 执行 git push origin master 时，它的意思是推送本地的 master 分支到远程 origin，涉及到远程以及分支，当然也得分开写了。 还可以一次性拉取多个分支的代码：git fetch origin master stable oldstable； 也还可以一次性合并多个分支的代码：git merge origin/master hotfix-2275 hotfix-2276 hotfix-2290； 1234567891011# 设置ss$ git config --global http.proxy &#x27;socks5://127.0.0.1:7890&#x27;$ git config --global https.proxy &#x27;socks5://127.0.0.1:7890&#x27;# 设置代理$ git config --global https.proxy http://127.0.0.1:7890$ git config --global https.proxy https://127.0.0.1:7890# 取消代理$ git config --global --unset http.proxy$ git config --global --unset https.proxy","categories":[{"name":"奇巧淫技","slug":"奇巧淫技","permalink":"http://www.furadwho.top/categories/%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.furadwho.top/tags/git/"}]},{"title":"Fabric 区块数据解析","slug":"Fabric-区块数据解析","date":"2021-10-21T03:38:27.000Z","updated":"2021-10-23T06:57:16.138Z","comments":true,"path":"2021/10/21/Fabric-区块数据解析/","link":"","permalink":"http://www.furadwho.top/2021/10/21/Fabric-%E5%8C%BA%E5%9D%97%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/","excerpt":"","text":"Fabric 区块数据解析这个文章主要是使用 Go 对于 Fabric 的区块数据进行解析。因为之前要搞一个在 Fabric 基础之上的区块链浏览器，使用的是 Fabric-Go-SDK ，就得对于他这区块数据进行一个解析，说实话，确实麻烦。 区块分析首先，区块链之中的区块结构就是包含区块头，区块体。但是 Fabric 的区块数据结构有一些变化，看下面的图我们也能看出来，Block Header（区块头），Block Data（区块体，包含所有的交易信息），加上 Block MetaData（当前区块的相关元数据）。这些数据我们几乎都是可以通过解析进行获取到的。 英文的区块结构说明： 中文的区块结构说明： 数据结构： 在我的参考文档之中有个很长的 JSON 格式数据（勉强看一眼）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178&#123; &quot;header&quot;: &#123; &quot;number&quot;: &quot;14&quot;, &quot;previous_hash&quot;: &quot;057935b395be9d6757f61a62eea2fd5c37e7089f3c991a7a9a131aefb255d450&quot;, &quot;data_hash&quot;: &quot;39ba8f0e54e75980414b301a343f42981ba63f8f105cd72d0e039010843aa920&quot; &#125;, &quot;data&quot;: &#123; &quot;data&quot;: [&#123; &quot;signature&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [48, 68, 2, 32, 53, 212, 86, 141, 134, 170, 144, 75, 132, 68, 229, 103, 122, 240, 21, 201, 139, 191, 77, 193, 50, 192, 31, 9, 15, 187, 65, 112, 239, 36, 205, 182, 2, 32, 98, 217, 249, 62, 93, 24, 158, 247, 180, 186, 122, 237, 141, 54, 228, 20, 218, 234, 24, 246, 118, 205, 134, 187, 250, 198, 255, 79, 129, 159, 164, 220] &#125;, &quot;payload&quot;: &#123; &quot;header&quot;: &#123; &quot;channel_header&quot;: &#123; &quot;type&quot;: 3, &quot;version&quot;: 1, &quot;timestamp&quot;: &quot;2021-01-10T12:01:29.673Z&quot;, &quot;channel_id&quot;: &quot;common&quot;, &quot;tx_id&quot;: &quot;ff28b4847400b16742245590d908b57a3643e4cc62baf3264dd8751070342314&quot;, &quot;epoch&quot;: &quot;0&quot;, &quot;extension&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [18, 11, 18, 9, 99, 104, 97, 105, 110, 99, 111, 100, 101] &#125;, &quot;typeString&quot;: &quot;ENDORSER_TRANSACTION&quot; &#125;, &quot;signature_header&quot;: &#123; &quot;creator&quot;: &#123; &quot;Mspid&quot;: &quot;org1&quot;, &quot;IdBytes&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIICcTCCAhegAwIBAgIUbtNpC7qvKr1n5OxgOZiaBRu2VtgwCgYIKoZIzj0EAwIw\\nczELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNh\\nbiBGcmFuY2lzY28xGTAXBgNVBAoTEG9yZzEuZXhhbXBsZS5jb20xHDAaBgNVBAMT\\nE2NhLm9yZzEuZXhhbXBsZS5jb20wHhcNMjEwMTEwMTE1NjAwWhcNMjIwMTEwMTIw\\nMTAwWjAvMRwwDQYDVQQLEwZjbGllbnQwCwYDVQQLEwRvcmcxMQ8wDQYDVQQDEwZh\\nZG1pbjEwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASlFdeOOyJRw4/25L62W/KA\\nmYpCFsV0CwnezSVEuJL44vC0vqpYUlk1CdR1UO8bkcutgBHXsly+gWyH+GZtSD59X\\no4HMMIHJMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBSu\\nKGe8YTCjfa0+f+l0Q6Woq+S94zArBgNVHSMEJDAigCA2OH3OJFJR5m75pJceBgqt\\ni7zg18hHdCVIjZOnvoUxazBdBggqAwQFBgcIAQRReyJhdHRycyI6eyJoZi5BZmZp\\nbGlhdGlvbiI6Im9yZzEiLCJoZi5FbnJvbGxtZW50SUQiOiJhZG1pbjEiLCJoZi5U\\neXBlIjoiY2xpZW50In19MAoGCCqGSM49BAMCA0gAMEUCIQCiNYmu/NaH/pBStOZf\\nfa2OcoTmBsJvztFikt/+CGjZ0gIgUJd1Ay3vi1V/WNMoAxr/3uA84qwAP0TRwcQw\\nIjyEzZA=\\n-----END CERTIFICATE-----\\n&quot; &#125;, &quot;nonce&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [217, 120, 226, 190, 89, 228, 29, 80, 164, 122, 27, 114, 128, 137, 117, 209, 53, 235, 81, 90, 147, 12, 11, 218] &#125; &#125; &#125;, &quot;data&quot;: &#123; &quot;actions&quot;: [&#123; &quot;header&quot;: &#123; &quot;creator&quot;: &#123; &quot;Mspid&quot;: &quot;org1&quot;, &quot;IdBytes&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIICcTCCAhegAwIBAgIUbtNpC7qvKr1n5OxgOZiaBRu2VtgwCgYIKoZIzj0EAwIw\\nczELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNh\\nbiBGcmFuY2lzY28xGTAXBgNVBAoTEG9yZzEuZXhhbXBsZS5jb20xHDAaBgNVBAMT\\nE2NhLm9yZzEuZXhhbXBsZS5jb20wHhcNMjEwMTEwMTE1NjAwWhcNMjIwMTEwMTIw\\nMTAwWjAvMRwwDQYDVQQLEwZj1bGllbnQwCwYDVQQLEwRvcmcxMQ8wDQYDVQQDEwZh\\nZG1pbjEwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASlFdeOOyJRw4/25L62W/KA\\nmYpCFsV0CwnezSVEuJL44vC0vqpYUlk1CdRUO8bkcutgBHXsly+gWyH+GZtSD59X\\no4HMMIHJMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBSu\\nKGe8YTCjfa0+f+l0Q6Woq+S94zArBgNVHSMEJDAigCA2OH3OJFJR5m75pJceBgqt\\ni7zg18hHdCVIjZOnvoUxazBdBggqAwQFBgcIAQRReyJhdHRycyI6eyJoZi5BZmZp\\nbGlhdGlvbiI6Im9yZzEiLCJoZi5FbnJvbGxtZW50SUQiOiJhZG1pbjEiLCJoZi5U\\neXBlIjoiY2xpZW50In19MAoGCCqGSM49BAMCA0gAMEUCIQCiNYmu/NaH/pBStOZf\\nfa2OcoTmBsJvztFikt/+CGjZ0gIgUJd1Ay3vi1V/WNMoAxr/3uA84qwAP0TRwcQw\\nIjyEzZA=\\n-----END CERTIFICATE-----\\n&quot; &#125;, &quot;nonce&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [217, 120, 226, 190, 89, 228, 29, 80, 164, 122, 27, 114, 128, 137, 117, 209, 53, 235, 81, 90, 147, 12, 11, 218] &#125; &#125;, &quot;payload&quot;: &#123; &quot;chaincode_proposal_payload&quot;: &#123; &quot;input&quot;: &#123; &quot;chaincode_spec&quot;: &#123; &quot;type&quot;: 1, &quot;typeString&quot;: &quot;GOLANG&quot;, &quot;input&quot;: &#123; &quot;args&quot;: [&#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [112, 117, 116] &#125;, &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [123, 34, 117, 115, 101, 114, 110, 97, 109, 101, 34, 12, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 34, 97, 99, 116, 105, 111, 110, 34, 58, 34, 115, 116, 111, 114, 101, 34, 44, 34, 109, 111, 110, 101, 121, 34, 58, 34, 50, 48, 48, 34, 125] &#125;], &quot;decorations&quot;: &#123;&#125; &#125;, &quot;chaincode_id&quot;: &#123; &quot;path&quot;: &quot;&quot;, &quot;name&quot;: &quot;chaincode&quot;, &quot;version&quot;: &quot;&quot; &#125;, &quot;timeout&quot;: 0 &#125; &#125; &#125;, &quot;action&quot;: &#123; &quot;proposal_response_payload&quot;: &#123; &quot;proposal_hash&quot;: &quot;932fb85e4b503cfdf2efbd8b9f45df5240da040cacd4c7970659263633c3afc3&quot;, &quot;extension&quot;: &#123; &quot;results&quot;: &#123; &quot;data_model&quot;: 0, &quot;ns_rwset&quot;: [&#123; &quot;namespace&quot;: &quot;chaincode&quot;, &quot;rwset&quot;: &#123; &quot;reads&quot;: [], &quot;range_queries_info&quot;: [], &quot;writes&quot;: [&#123; &quot;key&quot;: &quot;\\u0000neil\\u0000store\\u0000200\\u0000&quot;, &quot;is_delete&quot;: false, &quot;value&quot;: &quot;&#123;\\&quot;username\\&quot;:\\&quot;neil\\&quot;,\\&quot;action\\&quot;:\\&quot;store\\&quot;,\\&quot;money\\&quot;:\\&quot;200\\&quot;&#125;&quot; &#125;], &quot;metadata_writes&quot;: [] &#125;, &quot;collection_hashed_rwset&quot;: [] &#125;, &#123; &quot;namespace&quot;: &quot;lscc&quot;, &quot;rwset&quot;: &#123; &quot;reads&quot;: [&#123; &quot;key&quot;: &quot;chaincode&quot;, &quot;version&quot;: &#123; &quot;block_num&quot;: &quot;5&quot;, &quot;tx_num&quot;: &quot;0&quot; &#125; &#125;], &quot;range_queries_info&quot;: [], &quot;writes&quot;: [], &quot;metadata_writes&quot;: [] &#125;, &quot;collection_hashed_rwset&quot;: [] &#125;] &#125;, &quot;events&quot;: &#123; &quot;chaincode_id&quot;: &quot;&quot;, &quot;tx_id&quot;: &quot;&quot;, &quot;event_name&quot;: &quot;&quot;, &quot;payload&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [] &#125; &#125;, &quot;response&quot;: &#123; &quot;status&quot;: 200, &quot;message&quot;: &quot;&quot;, &quot;payload&quot;: &quot;&quot; &#125;, &quot;chaincode_id&quot;: &#123; &quot;path&quot;: &quot;&quot;, &quot;name&quot;: &quot;chaincode&quot;, &quot;version&quot;: &quot;1.0&quot; &#125; &#125; &#125;, &quot;endorsements&quot;: [&#123; &quot;endorser&quot;: &#123; &quot;Mspid&quot;: &quot;org1&quot;, &quot;IdBytes&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIICGTCCAcCgAwIBAgIRAP5eKKLGhfTuzLVPIrPcbTwwCgYIKoZIzj0EAwIwczEL\\nMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG\\ncmFuY2lzY28xGTAXBgNVBAoTEG9yZzEuZXhhbXBsZS5jb20xHDAaBgNVBAMTE2Nh\\nLm9yZzEuZXhhbXBsZS5jb20wHhcNMjEwMTEwMTA1NTAwWhcNMzEwMTA4MTA1NTAw\\nWjBbMQswCQ1YDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMN\\nU2FuIEZyYW5jaXNjbzEfMB0GA1UEAxMWcGVlcjAub3JnMS5leGFtcGxlLmNvbTBZ\\nMBMGByqGSM49AgEGCCqGSM49AwEHA0IABFo3HMBdd10LjYeZwMtR59Byjjp11pd8\\nlvWaItRsbrwDvAugdGDZ3KC1FVHLhblCbFp4sDyRDPwJIDnXYIZUpFWjTTBLMA4G\\nA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMCsGA1UdIwQkMCKAIDY4fc4kUlHm\\nbvmklx4GCq2LvODXyEd0JUiNk6e+hTFrMAoGCCqGSM49BAMCA0cAMEQCIE0PYDKu\\ncPYusfTbqem0AwtrqMx/2kUSP9X6/HA5en0lAiB/YePKYDu91h336nNcxal98vNB\\nPKyoL+zVCRqL/MYvCQ==\\n-----END CERTIFICATE-----\\n&quot; &#125;, &quot;signature&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [48, 68, 2, 32, 14, 77, 226, 146, 105, 55, 164, 194, 11, 71, 51, 147, 63, 74, 207, 104, 106, 187, 117, 175, 187, 194, 244, 165, 25, 132, 52, 8, 190, 217, 81, 46, 2, 32, 22, 123, 212, 121, 242, 138, 121, 213, 55, 113, 46, 11, 23, 119, 148, 62, 172, 83, 199, 24, 133, 151, 60, 144, 177, 255, 65, 182, 177, 225, 0, 222] &#125; &#125;] &#125; &#125; &#125;] &#125; &#125; &#125;] &#125;, &quot;metadata&quot;: &#123; &quot;metadata&quot;: [&#123; &quot;value&quot;: &quot;\\n\\u0002\\b\\u0003&quot;, &quot;signatures&quot;: [&#123; &quot;signature_header&quot;: &#123; &quot;creator&quot;: &#123; &quot;Mspid&quot;: &quot;orderer.example.com&quot;, &quot;IdBytes&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIICDTCCAbOgAwIBAgIRAKZzKwIm1fXv9TbfsLSlJpUwCgYIKoZIzj0EAwIwaTEL\\nMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG\\ncmFuY2lzY28xFDASBgNVBAoTC2V4YW1wbGUuY29tMRcwFQYDVQQDEw5jYS5leGFt\\ncGxlLmNvbTAeFw0yMTAxMTAxMDU1MDBaFw0zMTAxMDgxMDU1MDBaMFgxCzAJBgNV\\nBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1TYW4gRnJhbmNp\\nc2NvMRwwGgYDVQQDExNvcmRlcmVyLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0CAQYI\\nKoZIzj0DAQcDQgAEYh4Kui3YB02J9uUjX7+nn+l5ZT6DFWXjhB6X3fjUjowvySzf\\nfqn4s95o6qc0jYCaiC47cfUlJKvlPsBQX8XzyKNNMEswDgYDVR0PAQH/BAQDAgeA\\nMAwGA1UdEwEB/wQCMAAwKwYDVR0jBCQwIoAg1HCS4tEmcKJX2ttGPCY4mw2VSA5lP\\nkVeYrnAulge4U0gwCgYIKoZIzj0EAwIDSAAwRQIhAJQom8NqJdKvG3uYkbcuFRbx\\nUxVltC+/OdqLZ2ByCVWzAiAv0mGOCKPogI1QZdowWXsHtS9bZw3ymtwVToLXI+zP\\nzg==\\n-----END CERTIFICATE-----\\n&quot; &#125;, &quot;nonce&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [32, 137, 232, 144, 240, 168, 86, 24, 236, 47, 151, 23, 182, 223, 129, 176, 92, 209, 74, 104, 78, 83, 86, 125] &#125; &#125;, &quot;signature&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [48, 69, 2, 33, 0, 159, 188, 112, 227, 84, 54, 225, 211, 227, 157, 120, 16, 218, 64, 137, 137, 94, 9, 217, 83, 249, 31, 24, 66, 75, 78, 14, 219, 182, 220, 75, 223, 2, 32, 106, 39, 131, 38, 77, 200, 222, 147, 195, 62, 173, 63, 254, 133, 174, 73, 161, 75, 40, 248, 173, 62, 83, 56, 141, 99, 162, 94, 181, 72, 68, 188] &#125; &#125;] &#125;, &#123; &quot;value&quot;: &#123; &quot;index&quot;: &quot;3&quot; &#125;, &quot;signatures&quot;: [] &#125;, [0] ] &#125;&#125; 实际上也是为了说明上面提到的 header，data，metadata 这三个结构。 Block Header区块结构（Go common.Block） 12345678type Block struct &#123; Header *BlockHeader `protobuf:&quot;bytes,1,opt,name=header,proto3&quot; json:&quot;header,omitempty&quot;` Data *BlockData `protobuf:&quot;bytes,2,opt,name=data,proto3&quot; json:&quot;data,omitempty&quot;` Metadata *BlockMetadata `protobuf:&quot;bytes,3,opt,name=metadata,proto3&quot; json:&quot;metadata,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; Header 12345678type BlockHeader struct &#123; Number uint64 `protobuf:&quot;varint,1,opt,name=number,proto3&quot; json:&quot;number,omitempty&quot;` PreviousHash []byte `protobuf:&quot;bytes,2,opt,name=previous_hash,json=previousHash,proto3&quot; json:&quot;previous_hash,omitempty&quot;` DataHash []byte `protobuf:&quot;bytes,3,opt,name=data_hash,json=dataHash,proto3&quot; json:&quot;data_hash,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 区块头包含三个字段，Number（当前区块号）、PreviousHash（前一个区块头哈希）、DataHash（当前区块的数据哈希）。这个 DataHash 并不是当前区块的 Hash 值，只是当前区块数据体的 Hash ，所有我们要是计算当前区块的 Hash 就要自己进行一个计算。 计算过程很简单： 12345678910111213141516171819func GetBlockHash(blockHeader *common.BlockHeader) []byte &#123; rawBlockHeader := models.BlockHeader&#123; Number: int8(blockHeader.Number), PreviousHash: blockHeader.PreviousHash, DataHash: blockHeader.DataHash, &#125; data, err := asn1.Marshal(rawBlockHeader) if err != nil &#123; log.Printf(&quot;Failed to GetBlockHash : %s \\n&quot;, err) &#125; h := sha256.New() h.Write(data) byteHash := h.Sum(nil) return byteHash&#125; 这样的话，就可以获取到了当前区块的 Hash。 Block Data还是一样先看 SDK 里面定义的情况： 123456type BlockData struct &#123; Data [][]byte `protobuf:&quot;bytes,1,rep,name=data,proto3&quot; json:&quot;data,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 话说我也不知道为什么 Data 里面放的数据字段直接就对应上了 Envelope 这个数据结构，但是这个 Envelope 就是一种展示交易信息的结构： “Envelope wraps a Payload with a signature so that the message may be authenticated” 官方文档就来了这样的一句，多少有点。还是根据上面的那个结构图吧，确实有用只能说。 123456789type Envelope struct &#123; // A marshaled Payload Payload []byte `protobuf:&quot;bytes,1,opt,name=payload,proto3&quot; json:&quot;payload,omitempty&quot;` // A signature by the creator specified in the Payload header Signature []byte `protobuf:&quot;bytes,2,opt,name=signature,proto3&quot; json:&quot;signature,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 知道这个结构里面放着的是交易数据就可以了。。。 交易信息包括两个字段，Signature（交易发送者的签名）、Payload（数据载荷）。Signature是一个 buffer 数组类型的签名数据，并无其他可用信息，主要分析Payload数据载荷字段部分。 123456789type Payload struct &#123; // Header is included to provide identity and prevent replay Header *Header `protobuf:&quot;bytes,1,opt,name=header,proto3&quot; json:&quot;header,omitempty&quot;` // Data, the encoding of which is defined by the type in the header Data []byte `protobuf:&quot;bytes,2,opt,name=data,proto3&quot; json:&quot;data,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; Palyload 中包含了Header 和 Data 两个字段，其中 Header 中又包含了 ChannelHeader 和 SignatureHeader 1234567type Header struct &#123; ChannelHeader []byte `protobuf:&quot;bytes,1,opt,name=channel_header,json=channelHeader,proto3&quot; json:&quot;channel_header,omitempty&quot;` SignatureHeader []byte `protobuf:&quot;bytes,2,opt,name=signature_header,json=signatureHeader,proto3&quot; json:&quot;signature_header,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 具体的一个介绍： ChannelHeader ： type（头类型） version（版本） timestamp（时间戳，即交易产生时间） channel_id（通道id） tx_id（交易id，即交易哈希） epoch（时期，该字段当前未使用） extension（可附加的扩展） typeString（类型字符串，主要包括 MESSAGE、CONFIG（表示当前块为区块链配置块）、CONFIG_UPDATE、ENDORSER_TRANSACTION（表示当前块为区块链正常交易块，大多数区块都为此类型）、ORDERER_TRANSACTION、DELIVER_SEEK_INFO、CHAINCODE_PACKAGE等类型）。 SignatureHeader ： creator（交易创建者的信息）包括创建者的证书和Mspid（成员服务提供者的身份证书) ，可通过msp.SerializedIdentity解析。 nonce（随机数） Payload 之中的 Data 字段包含了所有交易的数据以及链码的调用和响应数据。可以把这个数据解析为 peer 里面的 Transaction。 12345678type Transaction struct &#123; // The payload is an array of TransactionAction. An array is necessary to // accommodate multiple actions per transaction Actions []*TransactionAction `protobuf:&quot;bytes,1,rep,name=actions,proto3&quot; json:&quot;actions,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 这里面的 Actions 就是一个交易的动作集合。 12345678910type TransactionAction struct &#123; // The header of the proposal action, which is the proposal header Header []byte `protobuf:&quot;bytes,1,opt,name=header,proto3&quot; json:&quot;header,omitempty&quot;` // The payload of the action as defined by the type in the header For // chaincode, it&#x27;s the bytes of ChaincodeActionPayload Payload []byte `protobuf:&quot;bytes,2,opt,name=payload,proto3&quot; json:&quot;payload,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; Header： 和SignatureHeader差不多，包含了用于提交交易的身份详细信息。 Payload： 可以通过ChainCodeActionPayload解析（包含着一些交易提案一类的信息）。 1234567891011121314151617type ChaincodeActionPayload struct &#123; // This field contains the bytes of the ChaincodeProposalPayload message from // the original invocation (essentially the arguments) after the application // of the visibility function. The main visibility modes are &quot;full&quot; (the // entire ChaincodeProposalPayload message is included here), &quot;hash&quot; (only // the hash of the ChaincodeProposalPayload message is included) or // &quot;nothing&quot;. This field will be used to check the consistency of // ProposalResponsePayload.proposalHash. For the CHAINCODE type, // ProposalResponsePayload.proposalHash is supposed to be H(ProposalHeader || // f(ChaincodeProposalPayload)) where f is the visibility function. ChaincodeProposalPayload []byte `` /* 135-byte string literal not displayed */ // The list of actions to apply to the ledger Action *ChaincodeEndorsedAction `protobuf:&quot;bytes,2,opt,name=action,proto3&quot; json:&quot;action,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 1234567891011121314type ChaincodeProposalPayload struct &#123; // Input contains the arguments for this invocation. If this invocation // deploys a new chaincode, ESCC/VSCC are part of this field. // This is usually a marshaled ChaincodeInvocationSpec Input []byte `protobuf:&quot;bytes,1,opt,name=input,proto3&quot; json:&quot;input,omitempty&quot;` // TransientMap contains data (e.g. cryptographic material) that might be used // to implement some form of application-level confidentiality. The contents // of this field are supposed to always be omitted from the transaction and // excluded from the ledger. TransientMap map[string][]byte `` /* 165-byte string literal not displayed */ XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 包含了调用chaincode时的输入参数等，Input：可以通过ChaincodeInvocationSpec解析 12345678910111213141516type ChaincodeInvocationSpec struct &#123; ChaincodeSpec *ChaincodeSpec `protobuf:&quot;bytes,1,opt,name=chaincode_spec,json=chaincodeSpec,proto3&quot; json:&quot;chaincode_spec,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125;type ChaincodeSpec struct &#123; Type ChaincodeSpec_Type `protobuf:&quot;varint,1,opt,name=type,proto3,enum=protos.ChaincodeSpec_Type&quot; json:&quot;type,omitempty&quot;` ChaincodeId *ChaincodeID `protobuf:&quot;bytes,2,opt,name=chaincode_id,json=chaincodeId,proto3&quot; json:&quot;chaincode_id,omitempty&quot;` Input *ChaincodeInput `protobuf:&quot;bytes,3,opt,name=input,proto3&quot; json:&quot;input,omitempty&quot;` Timeout int32 `protobuf:&quot;varint,4,opt,name=timeout,proto3&quot; json:&quot;timeout,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 携带链码函数及其参数。 等等！ 回到 ChaincodeActionPayload.Action。 可通过 ChaincodeEndorsedAction 解析，包含 Proposal Hash 及调用链码时的 Read/Write 的交易信息 123456789101112type ChaincodeEndorsedAction struct &#123; // This is the bytes of the ProposalResponsePayload message signed by the // endorsers. Recall that for the CHAINCODE type, the // ProposalResponsePayload&#x27;s extenstion field carries a ChaincodeAction ProposalResponsePayload []byte `` /* 132-byte string literal not displayed */ // The endorsement of the proposal, basically the endorser&#x27;s signature over // proposalResponsePayload Endorsements []*Endorsement `protobuf:&quot;bytes,2,rep,name=endorsements,proto3&quot; json:&quot;endorsements,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; ChaincodeEndorsedAction 携带有关特定提案背书的信息。 Endorsements 该字段包含背书者信息数组，每个背书者包含MspId、证书和此次背书的签名signature。 1234567891011121314151617type ProposalResponsePayload struct &#123; // Hash of the proposal that triggered this response. The hash is used to // link a response with its proposal, both for bookeeping purposes on an // asynchronous system and for security reasons (accountability, // non-repudiation). The hash usually covers the entire Proposal message // (byte-by-byte). ProposalHash []byte `protobuf:&quot;bytes,1,opt,name=proposal_hash,json=proposalHash,proto3&quot; json:&quot;proposal_hash,omitempty&quot;` // Extension should be unmarshaled to a type-specific message. The type of // the extension in any proposal response depends on the type of the proposal // that the client selected when the proposal was initially sent out. In // particular, this information is stored in the type field of a Header. For // chaincode, it&#x27;s a ChaincodeAction message Extension []byte `protobuf:&quot;bytes,2,opt,name=extension,proto3&quot; json:&quot;extension,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; ProposalResponsePayload 是提案响应的负载。此消息是客户端请求和背书人响应该请求的操作之间的“桥梁”。具体来说，对于链码，它包含提案的散列表示（proposalHash）和扩展字段内链码状态变化和事件的表示。 ProposalResponsePayload 字段包含链码模拟执行结果对KV类型状态数据库的读写集，包括 proposal_hash（背书哈希值） results（背书结果） data_model（数据模型，但含义未知，一般为0） ns_rwset（读写集数组）包含 namespace rwset包含 read（读集） writes（写集，包含键、值、删除标志） range_queries_info（范围查询信息） metadata_writes。 response（背书响应）包含 status（响应状态值） message（响应信息） payload（返回的数据，一般是查询时采用此字段）。 chaincode_id（链码信息） Extension可通过ChaincodeAction来解析，包含了Read/Write操作的交易 12345678910111213141516171819type ChaincodeAction struct &#123; // This field contains the read set and the write set produced by the // chaincode executing this invocation. Results []byte `protobuf:&quot;bytes,1,opt,name=results,proto3&quot; json:&quot;results,omitempty&quot;` // This field contains the event generated by the chaincode. // Only a single marshaled ChaincodeEvent is included. Events []byte `protobuf:&quot;bytes,2,opt,name=events,proto3&quot; json:&quot;events,omitempty&quot;` // This field contains the result of executing this invocation. Response *Response `protobuf:&quot;bytes,3,opt,name=response,proto3&quot; json:&quot;response,omitempty&quot;` // This field contains the ChaincodeID of executing this invocation. Endorser // will set it with the ChaincodeID called by endorser while simulating proposal. // Committer will validate the version matching with latest chaincode version. // Adding ChaincodeID to keep version opens up the possibility of multiple // ChaincodeAction per transaction. ChaincodeId *ChaincodeID `protobuf:&quot;bytes,4,opt,name=chaincode_id,json=chaincodeId,proto3&quot; json:&quot;chaincode_id,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; ChaincodeAction 包含执行的链码结果、响应和事件。 Results 可通过 TxReadWriteSet 解析 1234567type TxReadWriteSet struct &#123; DataModel TxReadWriteSet_DataModel `protobuf:&quot;varint,1,opt,name=data_model,json=dataModel,proto3,enum=rwset.TxReadWriteSet_DataModel&quot; json:&quot;data_model,omitempty&quot;` NsRwset []*NsReadWriteSet `protobuf:&quot;bytes,2,rep,name=ns_rwset,json=nsRwset,proto3&quot; json:&quot;ns_rwset,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; TxReadWriteSet 封装了一个事务的读写集 DataModel 指定数据模型的枚举值 ns_rwset 字段指定链码特定的读写集列表（每个链码一个）。 12345678type NsReadWriteSet struct &#123; Namespace string `protobuf:&quot;bytes,1,opt,name=namespace,proto3&quot; json:&quot;namespace,omitempty&quot;` Rwset []byte `protobuf:&quot;bytes,2,opt,name=rwset,proto3&quot; json:&quot;rwset,omitempty&quot;` CollectionHashedRwset []*CollectionHashedReadWriteSet `` /* 126-byte string literal not displayed */ XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; NsReadWriteSet 封装了链码的读写集。 123456789type KVRWSet struct &#123; Reads []*KVRead `protobuf:&quot;bytes,1,rep,name=reads,proto3&quot; json:&quot;reads,omitempty&quot;` RangeQueriesInfo []*RangeQueryInfo `protobuf:&quot;bytes,2,rep,name=range_queries_info,json=rangeQueriesInfo,proto3&quot; json:&quot;range_queries_info,omitempty&quot;` Writes []*KVWrite `protobuf:&quot;bytes,3,rep,name=writes,proto3&quot; json:&quot;writes,omitempty&quot;` MetadataWrites []*KVMetadataWrite `protobuf:&quot;bytes,4,rep,name=metadata_writes,json=metadataWrites,proto3&quot; json:&quot;metadata_writes,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; KVRWSet 封装了链码的读写集，该链码在 KV 或 Document 数据模型上运行此结构用于公共数据和私有数据。 到这我已经麻了，想看就看看，实在不行就找一份代码容易多了，艹。 Block MetaData元数据：和当前区块相关的元数据，用于描述 Data 的相关信息，包含排序节点的 MspId、证书和随机数，以及签名。 value 的 index 属性及一些其他的字段含义也不太清楚，但是这些信息大多是空值并且与区块链相关状态信息并不相关。元数据是用于编码块元数据的通用结构。 1234567type Metadata struct &#123; Value []byte `protobuf:&quot;bytes,1,opt,name=value,proto3&quot; json:&quot;value,omitempty&quot;` Signatures []*MetadataSignature `protobuf:&quot;bytes,2,rep,name=signatures,proto3&quot; json:&quot;signatures,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 结语我的项目：https://github.com/FuradWho/GoExplore 大致的 Fabric 区块一个结构就是这样了，我想只要一直对应最开始的那几个图就完事了，就可以大致的完成一个区块链浏览器的全部数据解析了。具体的可以看一下我的项目，虽然我也是借鉴了大佬们的想法 QAQ 。","categories":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://www.furadwho.top/categories/Hyperledger-Fabric/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://www.furadwho.top/tags/Fabric/"}]},{"title":"hexo 常用命令","slug":"hexo-常用命令","date":"2021-10-21T02:28:31.000Z","updated":"2021-10-24T15:11:27.425Z","comments":true,"path":"2021/10/21/hexo-常用命令/","link":"","permalink":"http://www.furadwho.top/2021/10/21/hexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"常用 hexo 命令初始化命令123$ npm install hexo -g //安装hexo $ npm update hexo -g //更新hexo$ hexo init //初始化博客 命令简写123456$ hexo n &quot;博客名称&quot; = hexo new &quot;博客名称&quot; //新建一篇博客$ hexo g = hexo generate //生成页面$ hexo d = hexo deploy //部署 $ hexo new page &quot;name&quot; //新建页面$ hexo g -d //生成页面并部署$ hexo s = hexo server //启动服务器、本地预览 其它命令123456$ hexo server //hexo会监视文件变动并自动更新，无须重启服务器 $ hexo server -s //静态模式$ hexo server -p 5000 //更改端口$ hexo server -i 192.168.1.1 //自定义 IP地址$ hexo clean //清除缓存和已生成的静态文件，若是网页正常情况下可以忽略这条命令$ hexo help //帮助 博客头格式1234567# 通过如下字段,Hexo会自动添加博文分类和博文标签的相关配置---title: title # 添加博文标题categories: categories # 添加博文分类tags: tags # 添加博文标签---","categories":[{"name":"奇巧淫技","slug":"奇巧淫技","permalink":"http://www.furadwho.top/categories/%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.furadwho.top/tags/hexo/"}]},{"title":"一元线性回归及Java实现","slug":"一元线性回归及Java实现","date":"2021-08-15T13:03:44.000Z","updated":"2021-10-21T02:49:29.173Z","comments":true,"path":"2021/08/15/一元线性回归及Java实现/","link":"","permalink":"http://www.furadwho.top/2021/08/15/%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8F%8AJava%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"一元线性回归及Java实现回归问题回归问题是研究自变量和因变量之间关系的一种预测模型技术。例如我们可以通过回归模型去预测房价与房子面积之间的关系，一个人每周花在微信上的时间和他微信好友数量之间的关系等。 回归模型定义了输入和输出的关系。输入为现有信息，输出为预测。 一个预测问题在回归模型下的解决步骤为： 构造训练集； 学习，得到输入输出间的关系； 预测，通过学习得到的关系预测输出。 线性回归假设要使用回归模型预测一个人每周花在微信上的时间和微信好友数量之间的关系，可以用如下的表达式表示： y=ax+b+e 其中，y是你每周需要花费在微信上的时间，x是你的微信好友数量，e是误差。对于误差e，它不是一个定值，有一对y和x，就有一个e，e的值满足正态分布。 使用最小二乘法拟合对于上面的样本集，我们尝试用y=ax+b+ey=ax+b+e去进行拟合，那么可以得到： ∣e∣=∣ax+b−y∣ 误差大小其实就是猜想的ax+bax+b的值和观测到的y值之间的差值。把所有的∣e∣∣e∣都求和，构造一个函数： Q=n∑(axi+b−yi)2 当QQ最小的时候，即可得到最佳拟合的直线。 编码实现首先构造一个类来存放记录： 12345678910111213141516171819public class DataNode &#123; private double x; private double y; public double getX() &#123; return x; &#125; public double getY() &#123; return y; &#125; public void setX(double x) &#123; this.x = x; &#125; public void setY(double y) &#123; this.y = y; &#125; public double getXY()&#123; return this.x * this.y; &#125;&#125; 然后构造MyLinearRegression类 12345678910111213141516171819202122232425262728293031public class MyLinearRegression &#123; private List&lt;DataNode&gt; list; private double alpha; private double beta; private double r; public MyLinearRegression(String path) throws IOException&#123; this.list = new ArrayList&lt;DataNode&gt;(); init(path); &#125; public double getAlpha() &#123; return alpha; &#125; public double getBeta() &#123; return beta; &#125; public double getR()&#123; return this.r; &#125; private void init(String path) throws IOException&#123; BufferedReader reader = new BufferedReader(new FileReader(new File(path))); String line = &quot;&quot;; while ((line = reader.readLine()) != null)&#123; String str[] = line.split(&quot;,&quot;); DataNode dataNode = new DataNode(); dataNode.setX(Double.parseDouble(str[0])); dataNode.setY(Double.parseDouble(str[1])); this.list.add(dataNode); &#125; reader.close(); &#125;&#125; 最后要根据读取到的数据去求alpha，beta和r的值。可以直接利用上面的公式： 1234567891011121314151617181920212223242526272829public void getAB()&#123; int n = list.size(); double sumX = 0; double sumY = 0; double sumXY = 0; double sumX2 = 0; for (DataNode dataNode : list)&#123; sumX += dataNode.getX(); sumY += dataNode.getY(); sumXY += dataNode.getXY(); sumX2 += Math.pow(dataNode.getX(), 2); &#125; this.alpha = (((sumY * sumX) / n) - sumXY) / (((sumX * sumX) / n) - sumX2); this.beta = (sumY - this.alpha * sumX) / n;&#125;public void getR2()&#123; double num = 0; double den = 0; double sumY = 0; for (DataNode dataNode : list)&#123; sumY += dataNode.getY(); &#125; double avgY = sumY / list.size(); for (DataNode dataNode : list)&#123; num += Math.pow((dataNode.getY() - (dataNode.getX() * this.alpha + beta)), 2); den += Math.pow((dataNode.getY() - avgY), 2); &#125; this.r = 1 - (num / den);&#125; 使用上述数据集拟合： 1234567891011public class Main &#123; public static void main(String args[]) throws IOException&#123; String path = &quot;test.txt&quot;; MyLinearRegression linearRegression = new MyLinearRegression(path); linearRegression.getAB(); linearRegression.getR2(); System.out.println(&quot;alpha = &quot; + linearRegression.getAlpha()); System.out.println(&quot;beta = &quot; + linearRegression.getBeta()); System.out.println(&quot;R2 = &quot; + linearRegression.getR()); &#125;&#125; 得到结果： 123alpha = 0.6058710840658103beta = 26.861280144241604R2 = 0.9001321912140731","categories":[{"name":"Machine learning","slug":"Machine-learning","permalink":"http://www.furadwho.top/categories/Machine-learning/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.furadwho.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"阅后即焚（一）","slug":"阅后即焚（一）","date":"2021-08-14T15:00:21.000Z","updated":"2021-10-25T15:19:02.829Z","comments":true,"path":"2021/08/14/阅后即焚（一）/","link":"","permalink":"http://www.furadwho.top/2021/08/14/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"阅后即焚（一） 生命只是一连串孤立的片刻，靠着回忆和幻想，许多意义浮现了，然后消失，消失之后又浮现。 ——普鲁斯特《追忆似水年华》 “おげんきですか？わたしはげんきです”，而病床上的少女藤井树也喃喃的问“おげんきですか？わたしはげんきです”。 我爱你，想着你久久无法忘怀！ 曾经一度被说像“春天小熊”而感动，原来是一只来自挪威森林的小熊。“春天的原野里，你一个人正走着，对面走来一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说道：‘你好，小姐，和我一块儿打滚玩儿好么？’接着，你就和小熊抱在一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一大天。”很喜欢这段渡边对绿子说的话，喜欢得不得了。 我在桌前静静地看着你，越来越喜欢，越来越依赖，无法失去！ 我似乎又陷进了一个名叫爱情的陷涡之中，胃剧烈地难受像呕出灵魂一般的，无法释怀。又一个没有开头，没有结尾的故事。明明是一个矛盾的人，想靠近，又会无动于衷。","categories":[{"name":"阅后即焚","slug":"阅后即焚","permalink":"http://www.furadwho.top/categories/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://www.furadwho.top/tags/emo/"}]}],"categories":[{"name":"阅后即焚","slug":"阅后即焚","permalink":"http://www.furadwho.top/categories/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A/"},{"name":"Go","slug":"Go","permalink":"http://www.furadwho.top/categories/Go/"},{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://www.furadwho.top/categories/Hyperledger-Fabric/"},{"name":"闲谈","slug":"闲谈","permalink":"http://www.furadwho.top/categories/%E9%97%B2%E8%B0%88/"},{"name":"电影","slug":"电影","permalink":"http://www.furadwho.top/categories/%E7%94%B5%E5%BD%B1/"},{"name":"奇巧淫技","slug":"奇巧淫技","permalink":"http://www.furadwho.top/categories/%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/"},{"name":"Docker","slug":"Docker","permalink":"http://www.furadwho.top/categories/Docker/"},{"name":"区块链","slug":"区块链","permalink":"http://www.furadwho.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Machine learning","slug":"Machine-learning","permalink":"http://www.furadwho.top/categories/Machine-learning/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://www.furadwho.top/tags/emo/"},{"name":"go","slug":"go","permalink":"http://www.furadwho.top/tags/go/"},{"name":"Fabric","slug":"Fabric","permalink":"http://www.furadwho.top/tags/Fabric/"},{"name":"say","slug":"say","permalink":"http://www.furadwho.top/tags/say/"},{"name":"电影","slug":"电影","permalink":"http://www.furadwho.top/tags/%E7%94%B5%E5%BD%B1/"},{"name":"http","slug":"http","permalink":"http://www.furadwho.top/tags/http/"},{"name":"docker","slug":"docker","permalink":"http://www.furadwho.top/tags/docker/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://www.furadwho.top/tags/ubuntu/"},{"name":"区块链","slug":"区块链","permalink":"http://www.furadwho.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"git","slug":"git","permalink":"http://www.furadwho.top/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"http://www.furadwho.top/tags/hexo/"},{"name":"算法","slug":"算法","permalink":"http://www.furadwho.top/tags/%E7%AE%97%E6%B3%95/"}]}