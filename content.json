{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://www.furadwho.top","root":"/"},"pages":[{"title":"关于小站","date":"2021-10-23T12:05:24.563Z","updated":"2021-10-23T12:05:24.563Z","comments":false,"path":"about/index.html","permalink":"http://www.furadwho.top/about/index.html","excerpt":"","text":"关于这个小站这世上每个人的说话方式都如此拐弯抹角、闪烁其词，如此不负责任、如此微妙复杂。他们总是徒劳无功地严加防范，无时无刻不费尽心机，这让我困惑不解，最终只得随波逐流，用搞笑的办法蒙混过关，抑或默默颔首，任凭对方行事，即采取败北者的消极态度 —– 引言 本人男，已有二十余岁了，有时候回想一下似乎也咩有在这个世界上留下什么痕迹。空留一人，肚子里的各种传奇经历也只有在烂醉之后会一一道出罢了（有机会可以一起喝酒）。这个人记性不好，很多事情动不动就忘记了一干二净，技术水平也就那么回事儿，搞过不少的东西，说精通也不精通，只能说“爱好广泛”。 之前也想着开一个网站来记录，但是由于严重的拖延症导致一直在搁置着，磨磨蹭蹭，艹。 网站的主要内容就是一些儿生活琐事，电影书籍感想，技术类文档等等，现在还没有想到有什么的其他的用途，对了，交友应该也算是一个。 大概就是这样了…"},{"title":"分类","date":"2021-10-20T14:28:03.702Z","updated":"2021-10-20T14:28:03.702Z","comments":false,"path":"categories/index.html","permalink":"http://www.furadwho.top/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-10-20T14:28:03.702Z","updated":"2021-10-20T14:28:03.702Z","comments":false,"path":"books/index.html","permalink":"http://www.furadwho.top/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-10-23T14:00:48.363Z","updated":"2021-10-23T14:00:48.363Z","comments":true,"path":"links/index.html","permalink":"http://www.furadwho.top/links/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-10-23T11:24:28.543Z","updated":"2021-10-23T11:24:28.543Z","comments":false,"path":"/404.html","permalink":"http://www.furadwho.top/404.html","excerpt":"","text":""},{"title":"标签","date":"2021-10-20T14:28:03.704Z","updated":"2021-10-20T14:28:03.704Z","comments":false,"path":"tags/index.html","permalink":"http://www.furadwho.top/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-10-20T14:28:03.703Z","updated":"2021-10-20T14:28:03.703Z","comments":false,"path":"repository/index.html","permalink":"http://www.furadwho.top/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"阅后即焚（四）","slug":"阅后即焚（四）","date":"2021-10-29T06:48:38.000Z","updated":"2021-10-29T07:27:27.232Z","comments":true,"path":"2021/10/29/阅后即焚（四）/","link":"","permalink":"http://www.furadwho.top/2021/10/29/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"阅后即焚（四） 这东西真的很神奇，最近又开始在晚上想很多的东西，想和她的未来，想自己真的可以配上她吗，真的会有什么样的结果，或者什么样的。这种感觉真的好受也不好受，过着平庸的生活却有着这些很奇妙的幻想啊！ 有时候想些这样的事情，真的好累。 正值秋天，这周的天气真的好棒！每天都有太阳，每天都有微风，拖了把椅子坐在窗前，晒着太阳，傻傻的等待着消息的回复。看着窗外的明媚，想着心里的故事，似乎可以一直这样真的很好啊！前两天她和我说，想和我出去溜溜弯，心里真的很开心，我是一个内敛的人，至少在她的面前是这样的。活脱脱一个闷骚的男性，有的话我真的不知道怎么表达，我不想破坏现在的关系，心里也很珍惜这一段的关系，害怕自己的某一句，某一个过分的举动，伤害到了这段感情。我视它（她）如珍宝… 又是这样的一个下午，我在想着未来，想着一些虚无缥缈。她给我带来的感觉，我不知是否得当，但是要是想描述的话，只能是和我第一次追女生的感觉是一模一样的。胆小怯懦，不可言喻。应该是不得当的，至少这样的对比是不值当的。第一次见她是什么样的呢，我开始问自己这个问题，怎么在酒桌上的情场高手，当自己遇到了却不知道用什么言语来形容了呢？确实，我也发现自己不会用什么合适来描述了。那是一场集体活动军训，我们不是一个专业，学校的安排是不同院系在一起集训。就这样我们被分在了同一个小组里，当看她的第一秒，我就和旁边的好友说道“真好看啊！”没错，很俗套的遇见，被吸引，想表现自己。现在想想，就算记性在不好的我，也觉得很好看！ 枯燥的训练项目，令大家生厌，但她依旧每天带着笑容，我不敢直视，那是心中的太阳！ 在一次的无聊的等待期间，大家玩起了真心话的游戏，那也是我第一次和她说话。轮到我说自己的真心话，我就阐述了高中时候是怎么把女生气哭的，怎么样自己不知道如何安慰，就和她坐着一起哭的。阐述了自己追高中女孩子，追了三年多依旧没有什么回应的真心话。我也不知道，自己怎么就在那时候说了这些酒桌上的茶余饭后的故事，可能就是想把自己的故事和她分享一下，让她对于我有点兴趣吧。仅仅这样罢了。 当时她问我“那如果那个女孩子回来找你，你还会怎么样的面对？”，不知道为什么，对于这个问题还是记忆满深刻的，“如果她回来，我依旧会接受，无论她经历了什么”。真的，那时候或者说，半年前我依旧是这样想的，对于那段感情，尽管不美好，我还是不回去忘记。那是我青春的痕迹，只是它不似伤害在身体上留下了痕迹，它在心里让我珍藏。写到这，倒是显得我很渣男了，为什么口头说着喜欢，但是心里面还在想着另一段的感情？要是这么问，我也不知道应该如何回复了，这就是我吧，对于这些事情，很难遗忘。 不知道我这样回答给了她算是怎么样的反馈，她就没有在继续问下去了。不在言语了。我想应该到此为止了，毕竟这番话出来应该就是“渣男”石锤了。 后来啊，班长一直怂恿我主动一些，为什么有感觉却不想表达呢？嗯，直到现在我才搞懂，我害怕！没有什么多余的借口，单单是因为自己害怕罢了。","categories":[{"name":"阅后即焚","slug":"阅后即焚","permalink":"http://www.furadwho.top/categories/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://www.furadwho.top/tags/emo/"}]},{"title":"docker 学习","slug":"docker-学习","date":"2021-10-27T07:31:13.000Z","updated":"2021-10-28T04:28:29.609Z","comments":true,"path":"2021/10/27/docker-学习/","link":"","permalink":"http://www.furadwho.top/2021/10/27/docker-%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.furadwho.top/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.furadwho.top/tags/docker/"}]},{"title":"我奶奶都懂 HTPPS","slug":"我奶奶都懂-HTPPS","date":"2021-10-26T06:45:51.000Z","updated":"2021-10-26T06:56:26.484Z","comments":true,"path":"2021/10/26/我奶奶都懂-HTPPS/","link":"","permalink":"http://www.furadwho.top/2021/10/26/%E6%88%91%E5%A5%B6%E5%A5%B6%E9%83%BD%E6%87%82-HTPPS/","excerpt":"","text":"我奶奶都懂HTTPS HTTPS 概述HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。 就是在 HTTP 之下加进去了 SSL ，HTTPS 的安全基础就是 SSL 。 因此加密的详细内容就需要SSL HTTPS: URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。 HTTP默认采用80作为通讯端口，对于传输采用不加密的方式；HTTPS默认采用443，对于传输的数据进行加密传输。目前主流的网站基本上开始默认采用HTTPS作为通信方式。 对称加密对称加密算法的加密和解密都是用同一个密钥。 如果通信双方都各自持有同一个密钥，且没有别人知道，则两方的通信安全是可以被保证的（除非密钥被破解）。 然而，最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。如果由服务器生成一个密钥并传输给浏览器，这个传输过程中密钥被别人劫持，之后他就能用密钥解开双方传输的任何内容。如果浏览器内部预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的。这样，浏览器只要预存好世界上所有HTTPS网站的密钥就可以了。显然，这样做是不现实的。怎么办？解决这个问题，我们就需要非对称加密。 非对称加密非对称加密算法需要一组密钥对，分别是公钥和私钥，这两个密钥是成对出现的。 公钥加密的内容需要对应的私钥解密，私钥加密的内容需要对应的公钥解密。私钥由服务器自己保存，公钥发送给客户端。 客户端拿到公钥后可以对请求进行加密后发送给服务端，这时候就算中间被截获，没有私钥也无法解密发送的内容，这样确保了客户端发送到服务端数据的安全。 非对称加密改良 通过一组公钥私钥，已经可以保证单个方向传输的安全性，那用两组公钥私钥，是不是就能保证双向传输都安全了？请看下面的过程： 某网站拥有用于非对称加密的公钥A1、私钥A2；浏览器拥有用于非对称加密的公钥B1、私钥B2。 浏览器向网站服务器请求，服务器把公钥A1明文传输给浏览器。 浏览器把公钥B1明文传输给服务器。 之后浏览器向服务器传输的所有东西都用公钥A1加密，服务器收到后用私钥A2解密。由于只有服务器拥有私钥A2进行解密，所以能保证这条数据的安全。 服务器向浏览器传输的所有东西都用公钥B1加密，浏览器收到后用私钥B2解密。同上也可以保证这条数据的安全。 可见确实可行。抛开这里面仍有的漏洞不谈（下文会讲），HTTPS的加密却没使用这种方案，为什么？最主要的原因是非对称加密算法非常耗时，特别是加密解密一些较大数据的时候有些力不从心。而对称加密快很多。那我们能不能运用非对称加密的特性解决前面提到的对称加密的问题？ 非对称加密 + 对称加密 既然非对称加密耗时，我们考虑是否可以采用非对称加密+对称加密结合的方式，而且要尽量减少非对称加密的次数。非对称加密、解密各只需一次的方法： 某网站拥有用于非对称加密的公钥A1、私钥A2。 浏览器向网站服务器请求，服务器把公钥A1明文给传输浏览器。 浏览器随机生成一个用于对称加密的密钥X，用公钥A1加密后传给服务器。 服务器拿到后用私钥A2解密得到密钥X。 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密即可。 HTTPS基本就是采用了这种方案。但还是有漏洞的。 中间人攻击 中间人的确无法得到浏览器生成的对称密钥X，这个密钥本身被公钥A1加密，只有服务器才能用私钥A2进行解密。然而中间人却完全不需要拿到私钥A2就能劫持信息，请看： 某网站拥有用于非对称加密的公钥A1、私钥A2。 浏览器向网站服务器请求，服务器把公钥A1明文传输给浏览器。 中间人劫持到公钥A1，保存下来，把数据包中的公钥A1替换成自己伪造的公钥B1（它当然也拥有公钥B1对应的私钥B2）。 浏览器随机生成一个用于对称加密的密钥X，用公钥B1（浏览器不知道公钥被替换了）加密后传给服务器。 中间人劫持后用私钥B2解密得到密钥X，再用公钥A1加密后传给服务器。 服务器拿到后用私钥A2解密得到密钥X。 这样在双方都不会发现异常的情况下，中间人得到了对称密钥X。根本原因是浏览器无法确认自己收到的公钥是不是网站自己的。那么下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？ 数字证书现实生活中，如果想证明某身份证号一定是小明的，怎么办？看身份证。这里政府机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中也有这么一个公信机构，CA 机构。 网站在使用HTTPS前，需要向“CA机构”申请颁发一数字证书，数字证书里有证书持有者、证书持有者的公钥等信息。服务器把证书传输给浏览器，浏览器从证书里取公钥就可以了。然而这里又有一个显而易见的问题：证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？数字证书怎么防伪呢？ 服务器提交自己的基本信息想CA机构提出申请，CA机构在给服务器颁发证书的时候，会连同数字证书以及根据证书计算的摘要一同发送给服务器，且这个摘要是需要经过CA机构自己的私钥进行加密的。申请流程如下： 数字签名我们把证书内容生成一份“签名”，比对证书内容和签名是否一致就能察觉是否被篡改。这种技术就叫数字签名。下图中左侧是数字签名的制作过程，右侧是验证过程 数字签名的制作过程： CA拥有非对称加密的私钥和公钥。 CA对证书明文信息进行hash。 对hash后的值用私钥加密，得到数字签名。 明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包） 浏览器验证过程： 拿到证书，得到明文T1，数字签名S1。 用CA机构的公钥对S1解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S2。 用证书里说明的hash算法对明文T1进行hash得到T2。 比较S2是否等于T2，等于则表明证书可信。 这里需要注意一点，一个是CA的公钥，内置在客户端，用来解密数字签名！另一个是目标服务器的公钥，在数字证书内容里，用来协商对称密钥！ 为什么这样可以证明证书可信？假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。 既然不可能篡改，那如果整个证书被掉包呢？假设有另一个网站B也拿到了CA机构认证的证书，它想搞垮网站A，想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，会导致上文提到的漏洞。其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。 制作数字签名时为什么需要hash一次？最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加密解密就会快很多。当然除此之外也有安全上的原因。 HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？用session就可以。服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了 HTTPS 工作原理 client向server发送请求https://baidu.com，然后连接到server的443端口。 服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。 传送证书这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。 客户端解析证书这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（密钥）。然后用证书对该随机值进行加密。 传送加密信息这部分传送的是用证书加密后的密钥（随机值），目的就是让服务端得到这个密钥（随机值），以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务端加密信息服务端用私钥解密，得到了客户端传过来的密钥（随机值），然后把内容通过该值进行对称加密。 传输加密后的信息这部分信息是服务端用密钥（随机值）对称加密后的信息，可以在客户端被还原。 客户端解密信息客户端用之前生成的密钥（随机值）解密服务端传过来的信息，于是获取了解密后的内容。 自签名证书 和 SpringBoot单双向认证配置及测试下载和安装OpenSSL下载其他人做的便捷版安装包 http://slproweb.com/products/Win32OpenSSL.html 配置环境变量配置环境变量，老生常谈，这里简单贴一下配置OPENSSL_HOME 测试命令： 1openssl version 生成根证书私钥12345678openssl genrsa -aes256 -out private/cakey.pem 1024命令含义如下：genrsa 使用RSA算法产生私钥-aes256 使用256位密钥的AES算法对私钥进行加密-out 输出文件的路径1024 指定私钥长度 生成证书请求（ca.csr)12345678910openssl req -new -key private/cakey.pem -out private/ca.csr -subj “/C=CN/ST=ZHEJIANG/L=HANGZHOU/O=TEST/OU=mygroup/CN=TEST”该命令含义如下：req 执行证书签发命令-new 新证书签发请求-key 指定私钥路径-out 输出的csr文件的路径-subj 证书相关的用户信息(subject的缩写)备注：这里需要输入私钥密码； 检查证书请求信息1openssl req -text -in ca.csr -noout 自签发根证书1234567891011openssl x509 -req -days 365 -sha1 -extensions v3_ca -signkey private/cakey.pem -in private/ca.csr -out certs/ca.cer该命令的含义如下：x509 生成x509格式证书-req 输入csr文件-days 证书的有效期（天）-sha1 证书摘要采用sha1算法-extensions 按照openssl.cnf文件中配置的v3_ca项添加扩展-signkey 签发证书的私钥-in 要输入的csr文件-out 输出的cer证书文件 其他操作： https://www.cxyzjd.com/article/skytering/103247128 SpringBoot配置文件： 123456server.port=443server.ssl.enabled=trueserver.ssl.key-store= src/main/resources/server.jksserver.ssl.key-store-password=Lzr20000306server.ssl.key-store-type=JKS 测试： 1、如果客户端想验证服务端证书，客户端需要安装服务端的公钥文件(cer)(或者服务端证书是官方CA颁发的，客户端可以直接联网认证)，因为服务端会将自己的随机数等信息使用自己的私钥加密之后发给客户端，而客户端要想解开这些数据，必须持有服务端的公钥才可以，之后服务端验证通过。 2、服务端想验证客户端证书，则需要将客户端的证书的公钥文件放到服务端trustStore信任库中，当客户端请求访问服务端时，会使用自己的私钥加密随机数、ssl版本等信息发送给服务端，服务端只有持有客户端的公钥才能解开这些数据，验证才能通过。 相关概念： 1.kestore(密钥库)和truststore(信任库)的区别： ​ Keystore，用来存放服务端证书，可以看成一个放key的库，key就是公钥，私钥，数字签名等组成的一个信息。 ​ Truststore是放服务端信任的客户端证书的一个store，里存放的是只包含公钥的数字证书，代表了可以信任的客户端证书， 而keystore是包含私钥的。 2.证书文件 – cer文件和pfx文件的区别 https://www.cnblogs.com/lthxk-yl/archive/2013/06/03/3115273.html 作为文件形式存在的证书一般有这几种格式： 1)、带有私钥的证书 ​ 由Public Key Cryptography Standards #12，PKCS#12标准定义，包含了公钥和私钥的二进制格式的证书形式，以pfx作 为证书文件后缀名。 2)、二进制编码的证书 ​ 证书中没有私钥，只包含公钥，DER 编码二进制格式的证书文件，以cer作为证书文件后缀名。 3)、Base64编码的证书 ​ 证书中没有私钥，只包含公钥，BASE64 编码格式的证书文件，也是以cer作为证书文件后缀名。 链接： https://blog.csdn.net/weixin_41917987/article/details/80988197?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control","categories":[{"name":"奇巧淫技","slug":"奇巧淫技","permalink":"http://www.furadwho.top/categories/%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/"}],"tags":[{"name":"Https","slug":"Https","permalink":"http://www.furadwho.top/tags/Https/"}]},{"title":"阅后即焚（三）","slug":"阅后即焚（三）","date":"2021-10-26T05:29:41.000Z","updated":"2021-10-27T11:59:45.781Z","comments":true,"path":"2021/10/26/阅后即焚（三）/","link":"","permalink":"http://www.furadwho.top/2021/10/26/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"阅后即焚（三） 人啊！还是得学习，每一个人可能学习的条件，学习得快慢，学习的时间，都是不一样的。但是，我觉得只要是在学习，应该就不负此生了！ 最近，我发现自己真的有点想家了，和家人一视频通话就会两个多小时，没什么话了也不想挂断。真脆弱啊！","categories":[{"name":"阅后即焚","slug":"阅后即焚","permalink":"http://www.furadwho.top/categories/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://www.furadwho.top/tags/emo/"}]},{"title":"Fabric-Go-SDk 学习（一）","slug":"Fabric-Go-SDk-学习（一）","date":"2021-10-25T13:41:36.000Z","updated":"2021-10-25T15:51:02.088Z","comments":true,"path":"2021/10/25/Fabric-Go-SDk-学习（一）/","link":"","permalink":"http://www.furadwho.top/2021/10/25/Fabric-Go-SDk-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"Fabric-Go-SDk 学习（一） 前言因为最近公司让我去学习 Hyperledger Fabric 并且用这个玩应儿和他的 Go SDK 做一个区块链浏览器，所以就有了这一阶段的学习。惯例吐槽一顿，按理说，Fabric本身都是用 Golang 开发的，那么 fabric-sdk-go 作为其亲儿子，功能应该是最为完善的，哈哈哈，事与愿违，Golang 版本的 sdk 反而是最不完备的，开发进度滞后，功能缺失。只能说，文档全是代码，一句介绍就完事了，真是有够简介的呢，草！ 网上有较多的学习方式都是借鉴 nodejs 版本的 sdk ，但是，我也没有深入的学习了解。换句话来说就是，有什么需求，我就去完成什么样的功能，石锤的工具人了! 大致说明GO SDK 还有很多的包，包里面也有乱七八糟的功能： pkg/fabsdk：主 package，主要用来生成 fabsdk 以及各种其他 pkg 使用的 option context (上下文)， 这些上下文由下面列出的客户端软件包使用。 pkg/client/channel：主要用来调用、查询链码，或者注册链码事件，提供频道交易相关功能。 pkg/client/resmgmt：主要用来 fabric 网络的管理，比如创建、加入通道，安装、实例化和升级链码。 pkg/client/event：配合 channel 模块来进行链码事件注册和过滤。 pkg/client/ledger：主要用来账本的查询，查询区块、交易、配置等。 pkg/client/msp：主要用来管理 fabric 的成员关系，身份管理相关功能。 一般情况的时候，使用这几个包就差不多完事了，够用！ 大致开发流程 使用配置实例化 fabsdk 实例。 使用 fabsdk 实例，基于用户和组织创建上下文 使用 New func 创建客户端实例，传递上下文。 使用每个客户提供的功能。 调用 fabsdk.Close（）来释放资源和缓存。 用官网给的一个例子： 1234567891011121314151617181920func TestLedgerClientQueries(t *testing.T) &#123; // Using shared SDK instance to increase test speed. sdk := mainSDK testSetup := mainTestSetup //prepare contexts org1AdminChannelContext := sdk.ChannelContext(testSetup.ChannelID, fabsdk.WithUser(org1AdminUser), fabsdk.WithOrg(org1Name)) // Ledger client client, err := ledger.New(org1AdminChannelContext) if err != nil &#123; t.Fatalf(&quot;Failed to create new resource management client: %s&quot;, err) &#125; ledgerInfo, err := client.QueryInfo() if err != nil &#123; t.Fatalf(&quot;QueryInfo return error: %s&quot;, err) &#125; ......&#125; 就可发现真的很好的说明了上面的过程，good！ Go SDK 包的学习只是一个大概的说明，具体的功能还是直接去查官网。 pkg/fabsdk fabsdk 包说明主 package，主要用来生成 fabsdk 以及各种其他 pkg 使用的 option context (上下文)， 这些上下文由下面列出的客户端软件包使用。 官网：https://pkg.go.dev/github.com/hyperledger/fabric-sdk-go@v1.0.0/pkg/fabsdk 变量 var ErrAnonymousIdentity = errors.New(&quot;missing credentials&quot;) ：当身份创建选项既不包含用户名也不包含身份时，将返回ErrAnonymousIdentity。 类型 ContextOption1type ContextOption func(s *identityOptions) error type ContextOption func(s *identityOptions) error: ContextOption：提供用于创建会话的参数（主要来自结构标识/用户）。 func WithIdentity(signingIdentity msp.SigningIdentity) ContextOption： WithIdentity 使用预先构造的身份对象作为会话的凭证。 func WithOrg(org string) ContextOption： WithOrg 使用指定的组织。 func WithUser(username string) ContextOption：WithUser 使用指定用户加载标识/身份。 类型 FabricSDK123type FabricSDK struct &#123; // contains filtered or unexported fields&#125; FabricSDK 为 SDK 管理的客户端提供访问（和上下文）。 func New(configProvider core.ConfigProvider, opts ...Option) (*FabricSDK, error)： New 根据提供的选项集初始化 SDK ， ConfigOptions提供应用程序配置。 func (sdk *FabricSDK) ChannelContext(channelID string, options ...ContextOption) contextApi.ChannelProvider：ChannelContext 创建并返回频道上下文。 func (sdk *FabricSDK) Close()：关闭释放 SDK 维护的缓存和连接。 func (sdk *FabricSDK) Config() (core.ConfigBackend, error)：Config 返回所有 SDK 配置类型使用的配置后端。 func (sdk *FabricSDK) Context(options ...ContextOption) contextApi.ClientProvider： Context 创建并返回具有所有必需提供者的上下文客户端。 类型 Option1type Option func(opts *options) error type Option func(opts *options) error：选项配置 SDK。 func WithCorePkg(core sdkApi.CoreProviderFactory) Option：WithCorePkg 将核心实现注入 SDK。 func WithCryptoSuiteConfig(cryptoConfigs ...interface&#123;&#125;) Option： WithCryptoSuiteConfig 向 SDK 注入。CryptoSuiteConfig 接口，它接受 CryptoSuiteConfig 的完整接口或每个实现 CryptoSuiteConfig 的一个（或多个）功能的子接口列表。 func WithEndpointConfig(endpointConfigs ...interface&#123;&#125;) Option：WithEndpointConfig 向 SDK 注入EndpointConfig 接口，它接受 EndpointConfig 的完整接口或每个实现 EndpointConfig 的一个（或多个）功能的子接口列表。 func WithIdentityConfig(identityConfigs ...interface&#123;&#125;) Option： WithIdentityConfig 向 SDK 注入IdentityConfig 接口，它接受 IdentityConfig 的完整接口或每个实现 IdentityConfig 的一个（或多个）功能的子接口列表。 func WithLoggerPkg(logger api.LoggerProvider) Option： WithLoggerPkg 将日志记录器实现注入到 SDK 中。 func WithMSPPkg(msp sdkApi.MSPProviderFactory) Option： WithMSPPkg 将 MSP 实现注入 SDK。 func WithServicePkg(service sdkApi.ServiceProviderFactory) Option： WithServicePkg 将服务实现注入 SDK。 pkg/client/channel channel 包说明主要用来调用、查询链码，或者注册链码事件，提供频道交易相关功能。 官网：https://pkg.go.dev/github.com/hyperledger/fabric-sdk-go@v1.0.0/pkg/client/channel 允许访问 Fabric 网络上的通道。通道客户端实例提供了一个处理程序来与指定通道上的对等点进行交互。通道客户端可以在特定通道上查询链码、执行链码和注册/取消注册链码事件。需要与多个通道交互的应用程序应该为每个通道创建一个单独的通道客户端实例。 类型 Client123type Client struct &#123; // contains filtered or unexported fields&#125; 客户端可以访问Fabric网络上的通道。通道客户端实例提供处理程序以与指定通道上的对等方交互。 需要与多个通道交互的应用程序应为每个通道创建一个单独的通道客户端实例。 通道客户端仅支持非管理功能。 func New(channelProvider context.ChannelProvider, opts ...ClientOption) (*Client, error)：New 返回一个 Client 实例。通道客户端可以在特定通道上查询链码、执行链码和注册/取消注册链码事件。 func (cc *Client) Execute(request Request, options ...RequestOption) (Response, error)：Execute （执行）使用请求和可选请求选项准备和执行事务。参数：请求包含有关强制链代码ID和功能的信息， options 包含可选的请求选项。返回：来自 peer 的提案回复。 func (cc *Client) InvokeHandler(handler invoke.Handler, request Request, options ...RequestOption) (Response, error)：InvokeHandler （调用处理程序）使用提供的请求和可选请求选项来调用处理程序。参数：要调用的处理程序，请求包含有关强制链代码 ID 和功能的信息，options 包含可选的请求选项。返回：来自peer的提案回复。 func (cc *Client) Query(request Request, options ...RequestOption) (Response, error)：Query （查询）使用请求和可选请求选项查询链代码。参数：请求包含有关强制链代码 ID 和功能的信息，options 包含可选的请求选项。返回：来自peer的提案回复。 func (cc *Client) RegisterChaincodeEvent(chainCodeID string, eventFilter string) (fab.Registration, &lt;-chan *fab.CCEvent, error)：RegisterChaincodeEvent（注册链码事件）注册链代码事件。 不再需要注册时，必须调用取消注册。参数：chaincodeID 是要为其接收事件的链代码 ID ，eventFilter 是要为其接收事件的 chaincode 事件过滤器（正则表达式）。返回：注册和用于接收事件的频道。 调用取消注册时，通道将关闭。 func (cc *Client) UnregisterChaincodeEvent(registration fab.Registration)：UnregisterChaincodeEvent（注销链码事件）删除给定的链码事件注册并关闭事件通道。参数：RegisterChaincodeEvent 方法返回的句柄。 类型 RequestOption1type ClientOption func(*Client) error ClientOption 描述了 New 构造函数的功能参数 类型 Request1234567891011121314151617type Request struct &#123; ChaincodeID string Fcn string Args [][]byte TransientMap map[string][]byte // InvocationChain contains meta-data that&#x27;s used by some Selection Service implementations // to choose endorsers that satisfy the endorsement policies of all chaincodes involved // in an invocation chain (i.e. for CC-to-CC invocations). // Each chaincode may also be associated with a set of private data collection names // which are used by some Selection Services (e.g. Fabric Selection) to exclude endorsers // that do NOT have read access to the collections. // The invoked chaincode (specified by ChaincodeID) may optionally be added to the invocation // chain along with any collections, otherwise it may be omitted. InvocationChain []*fab.ChaincodeCall IsInit bool&#125; Request 包含查询和执行调用事务的参数。 类型 RequestOption1type RequestOption func(ctx context.Client, opts *requestOptions) error 每个 Opts 参数的 RequestOption func。 func WithBeforeRetry(beforeRetry retry.BeforeRetryHandler) RequestOption：WithBeforeRetry （重试前）指定在重试尝试之前调用的函数。 func WithChaincodeFilter(ccFilter invoke.CCFilter) RequestOption：WithChaincodeFilter （链码过滤器）添加了一个链代码过滤器，用于计算额外的背书人。 func WithParentContext(parentContext reqContext.Context) RequestOption：WithParentContext（带父上下文）封装了 grpc 父上下文。","categories":[{"name":"Go","slug":"Go","permalink":"http://www.furadwho.top/categories/Go/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://www.furadwho.top/tags/Fabric/"}]},{"title":"阅后即焚（二）","slug":"阅后即焚（二）","date":"2021-10-25T06:28:43.000Z","updated":"2021-10-25T06:34:57.035Z","comments":true,"path":"2021/10/25/阅后即焚（二）/","link":"","permalink":"http://www.furadwho.top/2021/10/25/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"阅后即焚（二） 相寻梦里路，飞雨落花中。 —— 晏几道 很满足现在的生活，虽然因为疫情导致不能够去自己想去的地方。但是，似乎每天就这样的和舒服的人一起聊聊天，吹吹牛逼，也是真的不错。昨天晚上做了美梦，好久没有像现在记住这个梦很清晰的感觉了，只能说“小小美梦，大大知足”了。我不算什么大报复的人，只想着平平淡淡就好了……","categories":[{"name":"阅后即焚","slug":"阅后即焚","permalink":"http://www.furadwho.top/categories/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://www.furadwho.top/tags/emo/"}]},{"title":"Xshell、Idea与虚拟机Ubuntu连接","slug":"Xshell、Idea与虚拟机Ubuntu连接","date":"2021-10-23T16:31:39.000Z","updated":"2021-10-24T01:35:09.509Z","comments":true,"path":"2021/10/24/Xshell、Idea与虚拟机Ubuntu连接/","link":"","permalink":"http://www.furadwho.top/2021/10/24/Xshell%E3%80%81Idea%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E8%BF%9E%E6%8E%A5/","excerpt":"","text":"Xshell、Idea与虚拟机Ubuntu连接一、安装 Ubuntu 虚拟机默认VMware的网路是NAT模式，保持不变即可。获取宿主机以及虚拟机 IP 地址。 二、建立 IP 映射将宿主机和虚拟机的IP映射起来。 打开VMware的虚拟网络编辑器（编辑&gt;虚拟网络编辑器）： 选择 VMnet8 ，点击更改设置 选择 VMnet8 ，点击 NAT 设置 点击添加 主机端口，填写默认 22 即可 填入之前查到的虚拟机 IP 地址 虚拟机端口，填写默认的 22 即可 相当于将 宿主机 IP （192.168.80.106:22） 与虚拟机 IP （192.168.240.129:22) 建立起了映射关系。 三、配置虚拟机SSH 安装openssh-client：sudo apt-get install openssh-client 安装openssh-server：sudo apt-get install openssh-server 启动ssh-server：sudo /etc/init.d/ssh restart 确认ssh-server工作正常：netstat -tpl （看到ssh表示工作正常） 四、配置虚拟机防火墙启用22端口并重启防火墙： 12$ firewall-cmd --permanent --add-port=22/tcp $ firewall-cmd --reload 或者直接关闭防火墙： 1$ systemctl stop firewalld.service 五、使用 shell 连接虚拟机 六、配置 Idea 连接虚拟机在 Idea 上面点击如下菜单：Tools—Deployment—Configuration… 新增一台虚拟机，输入名称，选择SFTP协议，输入IP地址、代码路径、账号密码，点击OK 点击Tools—Deployment—Browse RemoteHost 右侧会出现对应的代码路径，修改完代码之后，可以点击右上角的upload图标，将代码上传到虚拟机 点击Tools—Start SSH session…可以打开远程界面 结语这样就可以在宿主机连接到虚拟机进行代码编辑，并且上传了。","categories":[{"name":"奇巧淫技","slug":"奇巧淫技","permalink":"http://www.furadwho.top/categories/%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://www.furadwho.top/tags/ubuntu/"}]},{"title":"《鲨鱼：起点》二刷","slug":"《鲨鱼：起点》二刷","date":"2021-10-23T12:55:26.000Z","updated":"2021-10-23T13:57:09.346Z","comments":true,"path":"2021/10/23/《鲨鱼：起点》二刷/","link":"","permalink":"http://www.furadwho.top/2021/10/23/%E3%80%8A%E9%B2%A8%E9%B1%BC%EF%BC%9A%E8%B5%B7%E7%82%B9%E3%80%8B%E4%BA%8C%E5%88%B7/","excerpt":"","text":"鲨鱼：起点 샤크: 더 비기닝 (2021)之前片荒的时候无意之中找到的一部韩国片子（还是漫改的），说实话，真论敢拍的话还得数大韩人民的电影。 从一开始的入坑韩国灾难片系列，像《流感》《潘多拉》之类，还有那些黑涩会片子，马东锡这种我觉得无敌的。就很少有觉得比较可以戳我点的韩国电影了。 这部片子总体上来说，故事情节也算是老套了。一个高中生因“校园霸凌”戳了对头的右眼，郎当入狱，被判了一个“杀人未遂”。同时，这不巧了，监狱里面有一个全国拳击冠军“哥”，在“哥”的带领之下，男主逐渐变得强大，一路打怪升级，最后打赢了对头。这种剧情确实感觉都已经被拍烂了，回想我当初为什么被这个片子戳到了，一方面应该就是韩国片的敢拍程度，真的算得上“拳拳到肉了”，相比于《悲伤》《少年的你》露骨程度已经超出了几个维度了。 在就可能是当时觉得，自己可能有的时候和里面的男主有点相似，不能说“校园霸凌”，只是觉得自己也想变得“强大”，至少不被人欺负，“想好好地做一个平凡人”。有的时候觉得，在当今这个社会，平平淡淡真的也是蛮难的。应该很多人都深有这种感受吧！所求平淡，又何来“平淡”…… 片子里面有一句，算是最戳动我： 鲨鱼因为没有鱼鰾，只要一刻不游动就会沉下去死掉 所以从出生到死亡，都要一刻不停地游动，不要停下！ Over……","categories":[{"name":"电影","slug":"电影","permalink":"http://www.furadwho.top/categories/%E7%94%B5%E5%BD%B1/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://www.furadwho.top/tags/%E7%94%B5%E5%BD%B1/"}]},{"title":"学了一个月，什么是Hyperledger Fabric","slug":"学了一个月，什么是Hyperledger-Fabric","date":"2021-10-23T07:06:01.000Z","updated":"2021-10-23T10:47:07.690Z","comments":true,"path":"2021/10/23/学了一个月，什么是Hyperledger-Fabric/","link":"","permalink":"http://www.furadwho.top/2021/10/23/%E5%AD%A6%E4%BA%86%E4%B8%80%E4%B8%AA%E6%9C%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AFHyperledger-Fabric/","excerpt":"","text":"","categories":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://www.furadwho.top/categories/Hyperledger-Fabric/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://www.furadwho.top/tags/Fabric/"}]},{"title":"学了两个月，什么是区块链","slug":"学了两个月，什么是区块链","date":"2021-10-23T07:05:01.000Z","updated":"2021-10-23T10:46:40.493Z","comments":true,"path":"2021/10/23/学了两个月，什么是区块链/","link":"","permalink":"http://www.furadwho.top/2021/10/23/%E5%AD%A6%E4%BA%86%E4%B8%A4%E4%B8%AA%E6%9C%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BA%E5%9D%97%E9%93%BE/","excerpt":"","text":"","categories":[{"name":"区块链","slug":"区块链","permalink":"http://www.furadwho.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://www.furadwho.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"Git 常用操作","slug":"Git-常用操作","date":"2021-10-22T02:10:53.000Z","updated":"2021-10-23T09:01:37.879Z","comments":true,"path":"2021/10/22/Git-常用操作/","link":"","permalink":"http://www.furadwho.top/2021/10/22/Git-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Git 常用操作比较常用的一些 Git 操作，但是日常只需要记住几个就可以。最近实习公司里面一直使用的 SVN ，但是我还是更偏向 Git 这个工具，怎么说呢，能有个地方放着就行了，哈哈哈 几个专用名词： Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 Git 学习Git是一个分布式版本管理系统，是为了更好地管理Linux内核开发而创立的。 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加 / 删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223242526272829# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all# merge 用merge的git路线是跳跃的，如果版本回退你也找不到自己想要的版本$ git pull = git fetch + git merge FETCH_HEAD # 使用rebase操作会更好一点，这样可以线性的看到每一次提交，并且没有增加提交节点$ git pull --rebase = git fetch + git rebase FETCH_HEAD 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他12# 生成一个可供发布的压缩包$ git archive 执行 git fetch origin master 时，它的意思是从名为 origin 的远程上拉取名为 master 的分支到本地分支 origin/master 中。既然是拉取代码，当然需要同时指定远程名与分支名，所以分开写。 执行 git merge origin/master 时，它的意思是合并名为 origin/master 的分支到当前所在分支。既然是分支的合并，当然就与远程名没有直接的关系，所以没有出现远程名。需要指定的是被合并的分支。 执行 git push origin master 时，它的意思是推送本地的 master 分支到远程 origin，涉及到远程以及分支，当然也得分开写了。 还可以一次性拉取多个分支的代码：git fetch origin master stable oldstable； 也还可以一次性合并多个分支的代码：git merge origin/master hotfix-2275 hotfix-2276 hotfix-2290；","categories":[{"name":"奇巧淫技","slug":"奇巧淫技","permalink":"http://www.furadwho.top/categories/%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.furadwho.top/tags/git/"}]},{"title":"Fabric 区块数据解析","slug":"Fabric-区块数据解析","date":"2021-10-21T03:38:27.000Z","updated":"2021-10-23T06:57:16.138Z","comments":true,"path":"2021/10/21/Fabric-区块数据解析/","link":"","permalink":"http://www.furadwho.top/2021/10/21/Fabric-%E5%8C%BA%E5%9D%97%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/","excerpt":"","text":"Fabric 区块数据解析这个文章主要是使用 Go 对于 Fabric 的区块数据进行解析。因为之前要搞一个在 Fabric 基础之上的区块链浏览器，使用的是 Fabric-Go-SDK ，就得对于他这区块数据进行一个解析，说实话，确实麻烦。 区块分析首先，区块链之中的区块结构就是包含区块头，区块体。但是 Fabric 的区块数据结构有一些变化，看下面的图我们也能看出来，Block Header（区块头），Block Data（区块体，包含所有的交易信息），加上 Block MetaData（当前区块的相关元数据）。这些数据我们几乎都是可以通过解析进行获取到的。 英文的区块结构说明： 中文的区块结构说明： 数据结构： 在我的参考文档之中有个很长的 JSON 格式数据（勉强看一眼）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178&#123; &quot;header&quot;: &#123; &quot;number&quot;: &quot;14&quot;, &quot;previous_hash&quot;: &quot;057935b395be9d6757f61a62eea2fd5c37e7089f3c991a7a9a131aefb255d450&quot;, &quot;data_hash&quot;: &quot;39ba8f0e54e75980414b301a343f42981ba63f8f105cd72d0e039010843aa920&quot; &#125;, &quot;data&quot;: &#123; &quot;data&quot;: [&#123; &quot;signature&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [48, 68, 2, 32, 53, 212, 86, 141, 134, 170, 144, 75, 132, 68, 229, 103, 122, 240, 21, 201, 139, 191, 77, 193, 50, 192, 31, 9, 15, 187, 65, 112, 239, 36, 205, 182, 2, 32, 98, 217, 249, 62, 93, 24, 158, 247, 180, 186, 122, 237, 141, 54, 228, 20, 218, 234, 24, 246, 118, 205, 134, 187, 250, 198, 255, 79, 129, 159, 164, 220] &#125;, &quot;payload&quot;: &#123; &quot;header&quot;: &#123; &quot;channel_header&quot;: &#123; &quot;type&quot;: 3, &quot;version&quot;: 1, &quot;timestamp&quot;: &quot;2021-01-10T12:01:29.673Z&quot;, &quot;channel_id&quot;: &quot;common&quot;, &quot;tx_id&quot;: &quot;ff28b4847400b16742245590d908b57a3643e4cc62baf3264dd8751070342314&quot;, &quot;epoch&quot;: &quot;0&quot;, &quot;extension&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [18, 11, 18, 9, 99, 104, 97, 105, 110, 99, 111, 100, 101] &#125;, &quot;typeString&quot;: &quot;ENDORSER_TRANSACTION&quot; &#125;, &quot;signature_header&quot;: &#123; &quot;creator&quot;: &#123; &quot;Mspid&quot;: &quot;org1&quot;, &quot;IdBytes&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIICcTCCAhegAwIBAgIUbtNpC7qvKr1n5OxgOZiaBRu2VtgwCgYIKoZIzj0EAwIw\\nczELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNh\\nbiBGcmFuY2lzY28xGTAXBgNVBAoTEG9yZzEuZXhhbXBsZS5jb20xHDAaBgNVBAMT\\nE2NhLm9yZzEuZXhhbXBsZS5jb20wHhcNMjEwMTEwMTE1NjAwWhcNMjIwMTEwMTIw\\nMTAwWjAvMRwwDQYDVQQLEwZjbGllbnQwCwYDVQQLEwRvcmcxMQ8wDQYDVQQDEwZh\\nZG1pbjEwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASlFdeOOyJRw4/25L62W/KA\\nmYpCFsV0CwnezSVEuJL44vC0vqpYUlk1CdR1UO8bkcutgBHXsly+gWyH+GZtSD59X\\no4HMMIHJMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBSu\\nKGe8YTCjfa0+f+l0Q6Woq+S94zArBgNVHSMEJDAigCA2OH3OJFJR5m75pJceBgqt\\ni7zg18hHdCVIjZOnvoUxazBdBggqAwQFBgcIAQRReyJhdHRycyI6eyJoZi5BZmZp\\nbGlhdGlvbiI6Im9yZzEiLCJoZi5FbnJvbGxtZW50SUQiOiJhZG1pbjEiLCJoZi5U\\neXBlIjoiY2xpZW50In19MAoGCCqGSM49BAMCA0gAMEUCIQCiNYmu/NaH/pBStOZf\\nfa2OcoTmBsJvztFikt/+CGjZ0gIgUJd1Ay3vi1V/WNMoAxr/3uA84qwAP0TRwcQw\\nIjyEzZA=\\n-----END CERTIFICATE-----\\n&quot; &#125;, &quot;nonce&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [217, 120, 226, 190, 89, 228, 29, 80, 164, 122, 27, 114, 128, 137, 117, 209, 53, 235, 81, 90, 147, 12, 11, 218] &#125; &#125; &#125;, &quot;data&quot;: &#123; &quot;actions&quot;: [&#123; &quot;header&quot;: &#123; &quot;creator&quot;: &#123; &quot;Mspid&quot;: &quot;org1&quot;, &quot;IdBytes&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIICcTCCAhegAwIBAgIUbtNpC7qvKr1n5OxgOZiaBRu2VtgwCgYIKoZIzj0EAwIw\\nczELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNh\\nbiBGcmFuY2lzY28xGTAXBgNVBAoTEG9yZzEuZXhhbXBsZS5jb20xHDAaBgNVBAMT\\nE2NhLm9yZzEuZXhhbXBsZS5jb20wHhcNMjEwMTEwMTE1NjAwWhcNMjIwMTEwMTIw\\nMTAwWjAvMRwwDQYDVQQLEwZj1bGllbnQwCwYDVQQLEwRvcmcxMQ8wDQYDVQQDEwZh\\nZG1pbjEwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASlFdeOOyJRw4/25L62W/KA\\nmYpCFsV0CwnezSVEuJL44vC0vqpYUlk1CdRUO8bkcutgBHXsly+gWyH+GZtSD59X\\no4HMMIHJMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBSu\\nKGe8YTCjfa0+f+l0Q6Woq+S94zArBgNVHSMEJDAigCA2OH3OJFJR5m75pJceBgqt\\ni7zg18hHdCVIjZOnvoUxazBdBggqAwQFBgcIAQRReyJhdHRycyI6eyJoZi5BZmZp\\nbGlhdGlvbiI6Im9yZzEiLCJoZi5FbnJvbGxtZW50SUQiOiJhZG1pbjEiLCJoZi5U\\neXBlIjoiY2xpZW50In19MAoGCCqGSM49BAMCA0gAMEUCIQCiNYmu/NaH/pBStOZf\\nfa2OcoTmBsJvztFikt/+CGjZ0gIgUJd1Ay3vi1V/WNMoAxr/3uA84qwAP0TRwcQw\\nIjyEzZA=\\n-----END CERTIFICATE-----\\n&quot; &#125;, &quot;nonce&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [217, 120, 226, 190, 89, 228, 29, 80, 164, 122, 27, 114, 128, 137, 117, 209, 53, 235, 81, 90, 147, 12, 11, 218] &#125; &#125;, &quot;payload&quot;: &#123; &quot;chaincode_proposal_payload&quot;: &#123; &quot;input&quot;: &#123; &quot;chaincode_spec&quot;: &#123; &quot;type&quot;: 1, &quot;typeString&quot;: &quot;GOLANG&quot;, &quot;input&quot;: &#123; &quot;args&quot;: [&#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [112, 117, 116] &#125;, &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [123, 34, 117, 115, 101, 114, 110, 97, 109, 101, 34, 12, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 34, 97, 99, 116, 105, 111, 110, 34, 58, 34, 115, 116, 111, 114, 101, 34, 44, 34, 109, 111, 110, 101, 121, 34, 58, 34, 50, 48, 48, 34, 125] &#125;], &quot;decorations&quot;: &#123;&#125; &#125;, &quot;chaincode_id&quot;: &#123; &quot;path&quot;: &quot;&quot;, &quot;name&quot;: &quot;chaincode&quot;, &quot;version&quot;: &quot;&quot; &#125;, &quot;timeout&quot;: 0 &#125; &#125; &#125;, &quot;action&quot;: &#123; &quot;proposal_response_payload&quot;: &#123; &quot;proposal_hash&quot;: &quot;932fb85e4b503cfdf2efbd8b9f45df5240da040cacd4c7970659263633c3afc3&quot;, &quot;extension&quot;: &#123; &quot;results&quot;: &#123; &quot;data_model&quot;: 0, &quot;ns_rwset&quot;: [&#123; &quot;namespace&quot;: &quot;chaincode&quot;, &quot;rwset&quot;: &#123; &quot;reads&quot;: [], &quot;range_queries_info&quot;: [], &quot;writes&quot;: [&#123; &quot;key&quot;: &quot;\\u0000neil\\u0000store\\u0000200\\u0000&quot;, &quot;is_delete&quot;: false, &quot;value&quot;: &quot;&#123;\\&quot;username\\&quot;:\\&quot;neil\\&quot;,\\&quot;action\\&quot;:\\&quot;store\\&quot;,\\&quot;money\\&quot;:\\&quot;200\\&quot;&#125;&quot; &#125;], &quot;metadata_writes&quot;: [] &#125;, &quot;collection_hashed_rwset&quot;: [] &#125;, &#123; &quot;namespace&quot;: &quot;lscc&quot;, &quot;rwset&quot;: &#123; &quot;reads&quot;: [&#123; &quot;key&quot;: &quot;chaincode&quot;, &quot;version&quot;: &#123; &quot;block_num&quot;: &quot;5&quot;, &quot;tx_num&quot;: &quot;0&quot; &#125; &#125;], &quot;range_queries_info&quot;: [], &quot;writes&quot;: [], &quot;metadata_writes&quot;: [] &#125;, &quot;collection_hashed_rwset&quot;: [] &#125;] &#125;, &quot;events&quot;: &#123; &quot;chaincode_id&quot;: &quot;&quot;, &quot;tx_id&quot;: &quot;&quot;, &quot;event_name&quot;: &quot;&quot;, &quot;payload&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [] &#125; &#125;, &quot;response&quot;: &#123; &quot;status&quot;: 200, &quot;message&quot;: &quot;&quot;, &quot;payload&quot;: &quot;&quot; &#125;, &quot;chaincode_id&quot;: &#123; &quot;path&quot;: &quot;&quot;, &quot;name&quot;: &quot;chaincode&quot;, &quot;version&quot;: &quot;1.0&quot; &#125; &#125; &#125;, &quot;endorsements&quot;: [&#123; &quot;endorser&quot;: &#123; &quot;Mspid&quot;: &quot;org1&quot;, &quot;IdBytes&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIICGTCCAcCgAwIBAgIRAP5eKKLGhfTuzLVPIrPcbTwwCgYIKoZIzj0EAwIwczEL\\nMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG\\ncmFuY2lzY28xGTAXBgNVBAoTEG9yZzEuZXhhbXBsZS5jb20xHDAaBgNVBAMTE2Nh\\nLm9yZzEuZXhhbXBsZS5jb20wHhcNMjEwMTEwMTA1NTAwWhcNMzEwMTA4MTA1NTAw\\nWjBbMQswCQ1YDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMN\\nU2FuIEZyYW5jaXNjbzEfMB0GA1UEAxMWcGVlcjAub3JnMS5leGFtcGxlLmNvbTBZ\\nMBMGByqGSM49AgEGCCqGSM49AwEHA0IABFo3HMBdd10LjYeZwMtR59Byjjp11pd8\\nlvWaItRsbrwDvAugdGDZ3KC1FVHLhblCbFp4sDyRDPwJIDnXYIZUpFWjTTBLMA4G\\nA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMCsGA1UdIwQkMCKAIDY4fc4kUlHm\\nbvmklx4GCq2LvODXyEd0JUiNk6e+hTFrMAoGCCqGSM49BAMCA0cAMEQCIE0PYDKu\\ncPYusfTbqem0AwtrqMx/2kUSP9X6/HA5en0lAiB/YePKYDu91h336nNcxal98vNB\\nPKyoL+zVCRqL/MYvCQ==\\n-----END CERTIFICATE-----\\n&quot; &#125;, &quot;signature&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [48, 68, 2, 32, 14, 77, 226, 146, 105, 55, 164, 194, 11, 71, 51, 147, 63, 74, 207, 104, 106, 187, 117, 175, 187, 194, 244, 165, 25, 132, 52, 8, 190, 217, 81, 46, 2, 32, 22, 123, 212, 121, 242, 138, 121, 213, 55, 113, 46, 11, 23, 119, 148, 62, 172, 83, 199, 24, 133, 151, 60, 144, 177, 255, 65, 182, 177, 225, 0, 222] &#125; &#125;] &#125; &#125; &#125;] &#125; &#125; &#125;] &#125;, &quot;metadata&quot;: &#123; &quot;metadata&quot;: [&#123; &quot;value&quot;: &quot;\\n\\u0002\\b\\u0003&quot;, &quot;signatures&quot;: [&#123; &quot;signature_header&quot;: &#123; &quot;creator&quot;: &#123; &quot;Mspid&quot;: &quot;orderer.example.com&quot;, &quot;IdBytes&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIICDTCCAbOgAwIBAgIRAKZzKwIm1fXv9TbfsLSlJpUwCgYIKoZIzj0EAwIwaTEL\\nMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG\\ncmFuY2lzY28xFDASBgNVBAoTC2V4YW1wbGUuY29tMRcwFQYDVQQDEw5jYS5leGFt\\ncGxlLmNvbTAeFw0yMTAxMTAxMDU1MDBaFw0zMTAxMDgxMDU1MDBaMFgxCzAJBgNV\\nBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1TYW4gRnJhbmNp\\nc2NvMRwwGgYDVQQDExNvcmRlcmVyLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0CAQYI\\nKoZIzj0DAQcDQgAEYh4Kui3YB02J9uUjX7+nn+l5ZT6DFWXjhB6X3fjUjowvySzf\\nfqn4s95o6qc0jYCaiC47cfUlJKvlPsBQX8XzyKNNMEswDgYDVR0PAQH/BAQDAgeA\\nMAwGA1UdEwEB/wQCMAAwKwYDVR0jBCQwIoAg1HCS4tEmcKJX2ttGPCY4mw2VSA5lP\\nkVeYrnAulge4U0gwCgYIKoZIzj0EAwIDSAAwRQIhAJQom8NqJdKvG3uYkbcuFRbx\\nUxVltC+/OdqLZ2ByCVWzAiAv0mGOCKPogI1QZdowWXsHtS9bZw3ymtwVToLXI+zP\\nzg==\\n-----END CERTIFICATE-----\\n&quot; &#125;, &quot;nonce&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [32, 137, 232, 144, 240, 168, 86, 24, 236, 47, 151, 23, 182, 223, 129, 176, 92, 209, 74, 104, 78, 83, 86, 125] &#125; &#125;, &quot;signature&quot;: &#123; &quot;type&quot;: &quot;Buffer&quot;, &quot;data&quot;: [48, 69, 2, 33, 0, 159, 188, 112, 227, 84, 54, 225, 211, 227, 157, 120, 16, 218, 64, 137, 137, 94, 9, 217, 83, 249, 31, 24, 66, 75, 78, 14, 219, 182, 220, 75, 223, 2, 32, 106, 39, 131, 38, 77, 200, 222, 147, 195, 62, 173, 63, 254, 133, 174, 73, 161, 75, 40, 248, 173, 62, 83, 56, 141, 99, 162, 94, 181, 72, 68, 188] &#125; &#125;] &#125;, &#123; &quot;value&quot;: &#123; &quot;index&quot;: &quot;3&quot; &#125;, &quot;signatures&quot;: [] &#125;, [0] ] &#125;&#125; 实际上也是为了说明上面提到的 header，data，metadata 这三个结构。 Block Header区块结构（Go common.Block） 12345678type Block struct &#123; Header *BlockHeader `protobuf:&quot;bytes,1,opt,name=header,proto3&quot; json:&quot;header,omitempty&quot;` Data *BlockData `protobuf:&quot;bytes,2,opt,name=data,proto3&quot; json:&quot;data,omitempty&quot;` Metadata *BlockMetadata `protobuf:&quot;bytes,3,opt,name=metadata,proto3&quot; json:&quot;metadata,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; Header 12345678type BlockHeader struct &#123; Number uint64 `protobuf:&quot;varint,1,opt,name=number,proto3&quot; json:&quot;number,omitempty&quot;` PreviousHash []byte `protobuf:&quot;bytes,2,opt,name=previous_hash,json=previousHash,proto3&quot; json:&quot;previous_hash,omitempty&quot;` DataHash []byte `protobuf:&quot;bytes,3,opt,name=data_hash,json=dataHash,proto3&quot; json:&quot;data_hash,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 区块头包含三个字段，Number（当前区块号）、PreviousHash（前一个区块头哈希）、DataHash（当前区块的数据哈希）。这个 DataHash 并不是当前区块的 Hash 值，只是当前区块数据体的 Hash ，所有我们要是计算当前区块的 Hash 就要自己进行一个计算。 计算过程很简单： 12345678910111213141516171819func GetBlockHash(blockHeader *common.BlockHeader) []byte &#123; rawBlockHeader := models.BlockHeader&#123; Number: int8(blockHeader.Number), PreviousHash: blockHeader.PreviousHash, DataHash: blockHeader.DataHash, &#125; data, err := asn1.Marshal(rawBlockHeader) if err != nil &#123; log.Printf(&quot;Failed to GetBlockHash : %s \\n&quot;, err) &#125; h := sha256.New() h.Write(data) byteHash := h.Sum(nil) return byteHash&#125; 这样的话，就可以获取到了当前区块的 Hash。 Block Data还是一样先看 SDK 里面定义的情况： 123456type BlockData struct &#123; Data [][]byte `protobuf:&quot;bytes,1,rep,name=data,proto3&quot; json:&quot;data,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 话说我也不知道为什么 Data 里面放的数据字段直接就对应上了 Envelope 这个数据结构，但是这个 Envelope 就是一种展示交易信息的结构： “Envelope wraps a Payload with a signature so that the message may be authenticated” 官方文档就来了这样的一句，多少有点。还是根据上面的那个结构图吧，确实有用只能说。 123456789type Envelope struct &#123; // A marshaled Payload Payload []byte `protobuf:&quot;bytes,1,opt,name=payload,proto3&quot; json:&quot;payload,omitempty&quot;` // A signature by the creator specified in the Payload header Signature []byte `protobuf:&quot;bytes,2,opt,name=signature,proto3&quot; json:&quot;signature,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 知道这个结构里面放着的是交易数据就可以了。。。 交易信息包括两个字段，Signature（交易发送者的签名）、Payload（数据载荷）。Signature是一个 buffer 数组类型的签名数据，并无其他可用信息，主要分析Payload数据载荷字段部分。 123456789type Payload struct &#123; // Header is included to provide identity and prevent replay Header *Header `protobuf:&quot;bytes,1,opt,name=header,proto3&quot; json:&quot;header,omitempty&quot;` // Data, the encoding of which is defined by the type in the header Data []byte `protobuf:&quot;bytes,2,opt,name=data,proto3&quot; json:&quot;data,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; Palyload 中包含了Header 和 Data 两个字段，其中 Header 中又包含了 ChannelHeader 和 SignatureHeader 1234567type Header struct &#123; ChannelHeader []byte `protobuf:&quot;bytes,1,opt,name=channel_header,json=channelHeader,proto3&quot; json:&quot;channel_header,omitempty&quot;` SignatureHeader []byte `protobuf:&quot;bytes,2,opt,name=signature_header,json=signatureHeader,proto3&quot; json:&quot;signature_header,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 具体的一个介绍： ChannelHeader ： type（头类型） version（版本） timestamp（时间戳，即交易产生时间） channel_id（通道id） tx_id（交易id，即交易哈希） epoch（时期，该字段当前未使用） extension（可附加的扩展） typeString（类型字符串，主要包括 MESSAGE、CONFIG（表示当前块为区块链配置块）、CONFIG_UPDATE、ENDORSER_TRANSACTION（表示当前块为区块链正常交易块，大多数区块都为此类型）、ORDERER_TRANSACTION、DELIVER_SEEK_INFO、CHAINCODE_PACKAGE等类型）。 SignatureHeader ： creator（交易创建者的信息）包括创建者的证书和Mspid（成员服务提供者的身份证书) ，可通过msp.SerializedIdentity解析。 nonce（随机数） Payload 之中的 Data 字段包含了所有交易的数据以及链码的调用和响应数据。可以把这个数据解析为 peer 里面的 Transaction。 12345678type Transaction struct &#123; // The payload is an array of TransactionAction. An array is necessary to // accommodate multiple actions per transaction Actions []*TransactionAction `protobuf:&quot;bytes,1,rep,name=actions,proto3&quot; json:&quot;actions,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 这里面的 Actions 就是一个交易的动作集合。 12345678910type TransactionAction struct &#123; // The header of the proposal action, which is the proposal header Header []byte `protobuf:&quot;bytes,1,opt,name=header,proto3&quot; json:&quot;header,omitempty&quot;` // The payload of the action as defined by the type in the header For // chaincode, it&#x27;s the bytes of ChaincodeActionPayload Payload []byte `protobuf:&quot;bytes,2,opt,name=payload,proto3&quot; json:&quot;payload,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; Header： 和SignatureHeader差不多，包含了用于提交交易的身份详细信息。 Payload： 可以通过ChainCodeActionPayload解析（包含着一些交易提案一类的信息）。 1234567891011121314151617type ChaincodeActionPayload struct &#123; // This field contains the bytes of the ChaincodeProposalPayload message from // the original invocation (essentially the arguments) after the application // of the visibility function. The main visibility modes are &quot;full&quot; (the // entire ChaincodeProposalPayload message is included here), &quot;hash&quot; (only // the hash of the ChaincodeProposalPayload message is included) or // &quot;nothing&quot;. This field will be used to check the consistency of // ProposalResponsePayload.proposalHash. For the CHAINCODE type, // ProposalResponsePayload.proposalHash is supposed to be H(ProposalHeader || // f(ChaincodeProposalPayload)) where f is the visibility function. ChaincodeProposalPayload []byte `` /* 135-byte string literal not displayed */ // The list of actions to apply to the ledger Action *ChaincodeEndorsedAction `protobuf:&quot;bytes,2,opt,name=action,proto3&quot; json:&quot;action,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 1234567891011121314type ChaincodeProposalPayload struct &#123; // Input contains the arguments for this invocation. If this invocation // deploys a new chaincode, ESCC/VSCC are part of this field. // This is usually a marshaled ChaincodeInvocationSpec Input []byte `protobuf:&quot;bytes,1,opt,name=input,proto3&quot; json:&quot;input,omitempty&quot;` // TransientMap contains data (e.g. cryptographic material) that might be used // to implement some form of application-level confidentiality. The contents // of this field are supposed to always be omitted from the transaction and // excluded from the ledger. TransientMap map[string][]byte `` /* 165-byte string literal not displayed */ XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 包含了调用chaincode时的输入参数等，Input：可以通过ChaincodeInvocationSpec解析 12345678910111213141516type ChaincodeInvocationSpec struct &#123; ChaincodeSpec *ChaincodeSpec `protobuf:&quot;bytes,1,opt,name=chaincode_spec,json=chaincodeSpec,proto3&quot; json:&quot;chaincode_spec,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125;type ChaincodeSpec struct &#123; Type ChaincodeSpec_Type `protobuf:&quot;varint,1,opt,name=type,proto3,enum=protos.ChaincodeSpec_Type&quot; json:&quot;type,omitempty&quot;` ChaincodeId *ChaincodeID `protobuf:&quot;bytes,2,opt,name=chaincode_id,json=chaincodeId,proto3&quot; json:&quot;chaincode_id,omitempty&quot;` Input *ChaincodeInput `protobuf:&quot;bytes,3,opt,name=input,proto3&quot; json:&quot;input,omitempty&quot;` Timeout int32 `protobuf:&quot;varint,4,opt,name=timeout,proto3&quot; json:&quot;timeout,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 携带链码函数及其参数。 等等！ 回到 ChaincodeActionPayload.Action。 可通过 ChaincodeEndorsedAction 解析，包含 Proposal Hash 及调用链码时的 Read/Write 的交易信息 123456789101112type ChaincodeEndorsedAction struct &#123; // This is the bytes of the ProposalResponsePayload message signed by the // endorsers. Recall that for the CHAINCODE type, the // ProposalResponsePayload&#x27;s extenstion field carries a ChaincodeAction ProposalResponsePayload []byte `` /* 132-byte string literal not displayed */ // The endorsement of the proposal, basically the endorser&#x27;s signature over // proposalResponsePayload Endorsements []*Endorsement `protobuf:&quot;bytes,2,rep,name=endorsements,proto3&quot; json:&quot;endorsements,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; ChaincodeEndorsedAction 携带有关特定提案背书的信息。 Endorsements 该字段包含背书者信息数组，每个背书者包含MspId、证书和此次背书的签名signature。 1234567891011121314151617type ProposalResponsePayload struct &#123; // Hash of the proposal that triggered this response. The hash is used to // link a response with its proposal, both for bookeeping purposes on an // asynchronous system and for security reasons (accountability, // non-repudiation). The hash usually covers the entire Proposal message // (byte-by-byte). ProposalHash []byte `protobuf:&quot;bytes,1,opt,name=proposal_hash,json=proposalHash,proto3&quot; json:&quot;proposal_hash,omitempty&quot;` // Extension should be unmarshaled to a type-specific message. The type of // the extension in any proposal response depends on the type of the proposal // that the client selected when the proposal was initially sent out. In // particular, this information is stored in the type field of a Header. For // chaincode, it&#x27;s a ChaincodeAction message Extension []byte `protobuf:&quot;bytes,2,opt,name=extension,proto3&quot; json:&quot;extension,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; ProposalResponsePayload 是提案响应的负载。此消息是客户端请求和背书人响应该请求的操作之间的“桥梁”。具体来说，对于链码，它包含提案的散列表示（proposalHash）和扩展字段内链码状态变化和事件的表示。 ProposalResponsePayload 字段包含链码模拟执行结果对KV类型状态数据库的读写集，包括 proposal_hash（背书哈希值） results（背书结果） data_model（数据模型，但含义未知，一般为0） ns_rwset（读写集数组）包含 namespace rwset包含 read（读集） writes（写集，包含键、值、删除标志） range_queries_info（范围查询信息） metadata_writes。 response（背书响应）包含 status（响应状态值） message（响应信息） payload（返回的数据，一般是查询时采用此字段）。 chaincode_id（链码信息） Extension可通过ChaincodeAction来解析，包含了Read/Write操作的交易 12345678910111213141516171819type ChaincodeAction struct &#123; // This field contains the read set and the write set produced by the // chaincode executing this invocation. Results []byte `protobuf:&quot;bytes,1,opt,name=results,proto3&quot; json:&quot;results,omitempty&quot;` // This field contains the event generated by the chaincode. // Only a single marshaled ChaincodeEvent is included. Events []byte `protobuf:&quot;bytes,2,opt,name=events,proto3&quot; json:&quot;events,omitempty&quot;` // This field contains the result of executing this invocation. Response *Response `protobuf:&quot;bytes,3,opt,name=response,proto3&quot; json:&quot;response,omitempty&quot;` // This field contains the ChaincodeID of executing this invocation. Endorser // will set it with the ChaincodeID called by endorser while simulating proposal. // Committer will validate the version matching with latest chaincode version. // Adding ChaincodeID to keep version opens up the possibility of multiple // ChaincodeAction per transaction. ChaincodeId *ChaincodeID `protobuf:&quot;bytes,4,opt,name=chaincode_id,json=chaincodeId,proto3&quot; json:&quot;chaincode_id,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; ChaincodeAction 包含执行的链码结果、响应和事件。 Results 可通过 TxReadWriteSet 解析 1234567type TxReadWriteSet struct &#123; DataModel TxReadWriteSet_DataModel `protobuf:&quot;varint,1,opt,name=data_model,json=dataModel,proto3,enum=rwset.TxReadWriteSet_DataModel&quot; json:&quot;data_model,omitempty&quot;` NsRwset []*NsReadWriteSet `protobuf:&quot;bytes,2,rep,name=ns_rwset,json=nsRwset,proto3&quot; json:&quot;ns_rwset,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; TxReadWriteSet 封装了一个事务的读写集 DataModel 指定数据模型的枚举值 ns_rwset 字段指定链码特定的读写集列表（每个链码一个）。 12345678type NsReadWriteSet struct &#123; Namespace string `protobuf:&quot;bytes,1,opt,name=namespace,proto3&quot; json:&quot;namespace,omitempty&quot;` Rwset []byte `protobuf:&quot;bytes,2,opt,name=rwset,proto3&quot; json:&quot;rwset,omitempty&quot;` CollectionHashedRwset []*CollectionHashedReadWriteSet `` /* 126-byte string literal not displayed */ XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; NsReadWriteSet 封装了链码的读写集。 123456789type KVRWSet struct &#123; Reads []*KVRead `protobuf:&quot;bytes,1,rep,name=reads,proto3&quot; json:&quot;reads,omitempty&quot;` RangeQueriesInfo []*RangeQueryInfo `protobuf:&quot;bytes,2,rep,name=range_queries_info,json=rangeQueriesInfo,proto3&quot; json:&quot;range_queries_info,omitempty&quot;` Writes []*KVWrite `protobuf:&quot;bytes,3,rep,name=writes,proto3&quot; json:&quot;writes,omitempty&quot;` MetadataWrites []*KVMetadataWrite `protobuf:&quot;bytes,4,rep,name=metadata_writes,json=metadataWrites,proto3&quot; json:&quot;metadata_writes,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; KVRWSet 封装了链码的读写集，该链码在 KV 或 Document 数据模型上运行此结构用于公共数据和私有数据。 到这我已经麻了，想看就看看，实在不行就找一份代码容易多了，艹。 Block MetaData元数据：和当前区块相关的元数据，用于描述 Data 的相关信息，包含排序节点的 MspId、证书和随机数，以及签名。 value 的 index 属性及一些其他的字段含义也不太清楚，但是这些信息大多是空值并且与区块链相关状态信息并不相关。元数据是用于编码块元数据的通用结构。 1234567type Metadata struct &#123; Value []byte `protobuf:&quot;bytes,1,opt,name=value,proto3&quot; json:&quot;value,omitempty&quot;` Signatures []*MetadataSignature `protobuf:&quot;bytes,2,rep,name=signatures,proto3&quot; json:&quot;signatures,omitempty&quot;` XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;` XXX_unrecognized []byte `json:&quot;-&quot;` XXX_sizecache int32 `json:&quot;-&quot;`&#125; 结语我的项目：https://github.com/FuradWho/GoExplore 大致的 Fabric 区块一个结构就是这样了，我想只要一直对应最开始的那几个图就完事了，就可以大致的完成一个区块链浏览器的全部数据解析了。具体的可以看一下我的项目，虽然我也是借鉴了大佬们的想法 QAQ 。","categories":[{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://www.furadwho.top/categories/Hyperledger-Fabric/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://www.furadwho.top/tags/Fabric/"}]},{"title":"hexo 常用命令","slug":"hexo-常用命令","date":"2021-10-21T02:28:31.000Z","updated":"2021-10-21T02:47:38.813Z","comments":true,"path":"2021/10/21/hexo-常用命令/","link":"","permalink":"http://www.furadwho.top/2021/10/21/hexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"常用 hexo 命令初始化命令123$ npm install hexo -g //安装hexo $ npm update hexo -g //更新hexo$ hexo init //初始化博客 命令简写123456$ hexo n &quot;博客名称&quot; = hexo new &quot;博客名称&quot; //新建一篇博客$ hexo g = hexo generate //生成页面$ hexo d = hexo deploy //部署 $ hexo new page &quot;name&quot; //新建页面$ hexo g -d //生成页面并部署$ hexo s = hexo server //启动服务器、本地预览 其它命令123456$ hexo server //hexo会监视文件变动并自动更新，无须重启服务器 $ hexo server -s //静态模式$ hexo server -p 5000 //更改端口$ hexo server -i 192.168.1.1 //自定义 IP地址$ hexo clean //清除缓存和已生成的静态文件，若是网页正常情况下可以忽略这条命令$ hexo help //帮助 博客头格式1234567# 通过如下字段,Hexo会自动添加博文分类和博文标签的相关配置---title: title # 添加博文标题categories: categories # 添加博文分类tags: tags # 添加博文标签---","categories":[{"name":"奇巧淫技","slug":"奇巧淫技","permalink":"http://www.furadwho.top/categories/%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.furadwho.top/tags/hexo/"}]},{"title":"一元线性回归及Java实现","slug":"一元线性回归及Java实现","date":"2021-08-15T13:03:44.000Z","updated":"2021-10-21T02:49:29.173Z","comments":true,"path":"2021/08/15/一元线性回归及Java实现/","link":"","permalink":"http://www.furadwho.top/2021/08/15/%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8F%8AJava%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"一元线性回归及Java实现回归问题回归问题是研究自变量和因变量之间关系的一种预测模型技术。例如我们可以通过回归模型去预测房价与房子面积之间的关系，一个人每周花在微信上的时间和他微信好友数量之间的关系等。 回归模型定义了输入和输出的关系。输入为现有信息，输出为预测。 一个预测问题在回归模型下的解决步骤为： 构造训练集； 学习，得到输入输出间的关系； 预测，通过学习得到的关系预测输出。 线性回归假设要使用回归模型预测一个人每周花在微信上的时间和微信好友数量之间的关系，可以用如下的表达式表示： y=ax+b+e 其中，y是你每周需要花费在微信上的时间，x是你的微信好友数量，e是误差。对于误差e，它不是一个定值，有一对y和x，就有一个e，e的值满足正态分布。 使用最小二乘法拟合对于上面的样本集，我们尝试用y=ax+b+ey=ax+b+e去进行拟合，那么可以得到： ∣e∣=∣ax+b−y∣ 误差大小其实就是猜想的ax+bax+b的值和观测到的y值之间的差值。把所有的∣e∣∣e∣都求和，构造一个函数： Q=n∑(axi+b−yi)2 当QQ最小的时候，即可得到最佳拟合的直线。 编码实现首先构造一个类来存放记录： 12345678910111213141516171819public class DataNode &#123; private double x; private double y; public double getX() &#123; return x; &#125; public double getY() &#123; return y; &#125; public void setX(double x) &#123; this.x = x; &#125; public void setY(double y) &#123; this.y = y; &#125; public double getXY()&#123; return this.x * this.y; &#125;&#125; 然后构造MyLinearRegression类 12345678910111213141516171819202122232425262728293031public class MyLinearRegression &#123; private List&lt;DataNode&gt; list; private double alpha; private double beta; private double r; public MyLinearRegression(String path) throws IOException&#123; this.list = new ArrayList&lt;DataNode&gt;(); init(path); &#125; public double getAlpha() &#123; return alpha; &#125; public double getBeta() &#123; return beta; &#125; public double getR()&#123; return this.r; &#125; private void init(String path) throws IOException&#123; BufferedReader reader = new BufferedReader(new FileReader(new File(path))); String line = &quot;&quot;; while ((line = reader.readLine()) != null)&#123; String str[] = line.split(&quot;,&quot;); DataNode dataNode = new DataNode(); dataNode.setX(Double.parseDouble(str[0])); dataNode.setY(Double.parseDouble(str[1])); this.list.add(dataNode); &#125; reader.close(); &#125;&#125; 最后要根据读取到的数据去求alpha，beta和r的值。可以直接利用上面的公式： 1234567891011121314151617181920212223242526272829public void getAB()&#123; int n = list.size(); double sumX = 0; double sumY = 0; double sumXY = 0; double sumX2 = 0; for (DataNode dataNode : list)&#123; sumX += dataNode.getX(); sumY += dataNode.getY(); sumXY += dataNode.getXY(); sumX2 += Math.pow(dataNode.getX(), 2); &#125; this.alpha = (((sumY * sumX) / n) - sumXY) / (((sumX * sumX) / n) - sumX2); this.beta = (sumY - this.alpha * sumX) / n;&#125;public void getR2()&#123; double num = 0; double den = 0; double sumY = 0; for (DataNode dataNode : list)&#123; sumY += dataNode.getY(); &#125; double avgY = sumY / list.size(); for (DataNode dataNode : list)&#123; num += Math.pow((dataNode.getY() - (dataNode.getX() * this.alpha + beta)), 2); den += Math.pow((dataNode.getY() - avgY), 2); &#125; this.r = 1 - (num / den);&#125; 使用上述数据集拟合： 1234567891011public class Main &#123; public static void main(String args[]) throws IOException&#123; String path = &quot;test.txt&quot;; MyLinearRegression linearRegression = new MyLinearRegression(path); linearRegression.getAB(); linearRegression.getR2(); System.out.println(&quot;alpha = &quot; + linearRegression.getAlpha()); System.out.println(&quot;beta = &quot; + linearRegression.getBeta()); System.out.println(&quot;R2 = &quot; + linearRegression.getR()); &#125;&#125; 得到结果： 123alpha = 0.6058710840658103beta = 26.861280144241604R2 = 0.9001321912140731","categories":[{"name":"Machine learning","slug":"Machine-learning","permalink":"http://www.furadwho.top/categories/Machine-learning/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.furadwho.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"阅后即焚（一）","slug":"阅后即焚（一）","date":"2021-08-14T15:00:21.000Z","updated":"2021-10-25T15:19:02.829Z","comments":true,"path":"2021/08/14/阅后即焚（一）/","link":"","permalink":"http://www.furadwho.top/2021/08/14/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"阅后即焚（一） 生命只是一连串孤立的片刻，靠着回忆和幻想，许多意义浮现了，然后消失，消失之后又浮现。 ——普鲁斯特《追忆似水年华》 “おげんきですか？わたしはげんきです”，而病床上的少女藤井树也喃喃的问“おげんきですか？わたしはげんきです”。 我爱你，想着你久久无法忘怀！ 曾经一度被说像“春天小熊”而感动，原来是一只来自挪威森林的小熊。“春天的原野里，你一个人正走着，对面走来一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说道：‘你好，小姐，和我一块儿打滚玩儿好么？’接着，你就和小熊抱在一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一大天。”很喜欢这段渡边对绿子说的话，喜欢得不得了。 我在桌前静静地看着你，越来越喜欢，越来越依赖，无法失去！ 我似乎又陷进了一个名叫爱情的陷涡之中，胃剧烈地难受像呕出灵魂一般的，无法释怀。又一个没有开头，没有结尾的故事。明明是一个矛盾的人，想靠近，又会无动于衷。","categories":[{"name":"阅后即焚","slug":"阅后即焚","permalink":"http://www.furadwho.top/categories/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://www.furadwho.top/tags/emo/"}]}],"categories":[{"name":"阅后即焚","slug":"阅后即焚","permalink":"http://www.furadwho.top/categories/%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A/"},{"name":"Docker","slug":"Docker","permalink":"http://www.furadwho.top/categories/Docker/"},{"name":"奇巧淫技","slug":"奇巧淫技","permalink":"http://www.furadwho.top/categories/%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/"},{"name":"Go","slug":"Go","permalink":"http://www.furadwho.top/categories/Go/"},{"name":"电影","slug":"电影","permalink":"http://www.furadwho.top/categories/%E7%94%B5%E5%BD%B1/"},{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://www.furadwho.top/categories/Hyperledger-Fabric/"},{"name":"区块链","slug":"区块链","permalink":"http://www.furadwho.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Machine learning","slug":"Machine-learning","permalink":"http://www.furadwho.top/categories/Machine-learning/"}],"tags":[{"name":"emo","slug":"emo","permalink":"http://www.furadwho.top/tags/emo/"},{"name":"docker","slug":"docker","permalink":"http://www.furadwho.top/tags/docker/"},{"name":"Https","slug":"Https","permalink":"http://www.furadwho.top/tags/Https/"},{"name":"Fabric","slug":"Fabric","permalink":"http://www.furadwho.top/tags/Fabric/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://www.furadwho.top/tags/ubuntu/"},{"name":"电影","slug":"电影","permalink":"http://www.furadwho.top/tags/%E7%94%B5%E5%BD%B1/"},{"name":"区块链","slug":"区块链","permalink":"http://www.furadwho.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"git","slug":"git","permalink":"http://www.furadwho.top/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"http://www.furadwho.top/tags/hexo/"},{"name":"算法","slug":"算法","permalink":"http://www.furadwho.top/tags/%E7%AE%97%E6%B3%95/"}]}